<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[whatamitoyou]]></title>
    <url>%2F2018%2F11%2F10%2Fwhatamitoyou%2F</url>
    <content type="text"><![CDATA[在linux里无法执行，于是查看文件发现没有执行权限，sudo chmod u+x 进行修改放进ida，找不到main函数，只能找到这个__libc_start_main .text:00000000004004AF mov r8, offset nullsub_1 .text:00000000004004B6 mov rcx, offset loc_4019A0 .text:00000000004004BD mov rdi, offset sub_400596 .text:00000000004004C4 call ___libc_start_main 而__libc_start_main定义如下，则可判定通过rdi传递的参数 sub_400596 即为 main 函数 int __libc_start_main(int *(main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)); 发现静态调试太复杂，结合 kali 下 edb 动态调试，以下是部分汇编代码 .text:00000000004005AE lea rdx, [rbp+var_140] ; 给140清零 .text:00000000004005B5 mov eax, 0 .text:00000000004005BA mov ecx, 25h .text:00000000004005BF mov rdi, rdx .text:00000000004005C2 rep stosq .text:00000000004005C5 mov rax, 6A20612049206D41h ; 在140 存歌词 .text:00000000004005CF mov [rbp+var_140], rax .text:00000000004005D6 mov rax, 756F79202C656B6Fh .text:00000000004005E0 mov [rbp+var_138], rax .text:00000000004005E7 mov rax, 746867696E6B2072h .text:00000000004005F1 mov [rbp+var_130], rax .text:00000000004005F8 mov rax, 756F7920726F202Ch .text:0000000000400602 mov [rbp+var_128], rax .text:0000000000400609 mov rax, 6568746F72622072h .text:0000000000400613 mov [rbp+var_120], rax .text:000000000040061A mov [rbp+var_118], 3F72h main 的开始就是这样的过程，先给一片区域清零然后放入歌词；然后是一大片赋值，把各个歌词的首地址存到另一个地方 .text:000000000040138D lea rax, [rbp+var_1900] ; 转存到另一个地址 .text:0000000000401394 mov [rbp+var_D50], rax .text:000000000040139B lea rax, [rbp+var_17D0] .text:00000000004013A2 mov [rbp+var_D48], rax .text:00000000004013A9 lea rax, [rbp+var_1570] .text:00000000004013B0 mov [rbp+var_D40], rax .text:00000000004013B7 lea rax, [rbp+var_140] .text:00000000004013BE mov [rbp+var_D38], rax .text:00000000004013C5 lea rax, [rbp+var_11E0] .text:00000000004013CC mov [rbp+var_1470], rax .text:00000000004013D3 lea rax, [rbp+var_1900] .text:00000000004013DA mov [rbp+var_1468], rax 最后栈空间大概是这样 00007ffc:2f3ae770|7327746920776f4e|Now it&#39;s| 00007ffc:2f3ae778|67203b656e6f6720| gone; g| 00007ffc:2f3ae780|65726f6620656e6f|one fore| 00007ffc:2f3ae788|000000002c726576|ver,....| 00007ffc:2f3ae790|0000000000000000|........| 00007ffc:2f3ae7a0|0000000000000000|........| ...... 00007ffc:2f3ae860|0000000000000000|........| 00007ffc:2f3ae868|0000000000000000|........| 00007ffc:2f3ae870|00007ffc2f3adf20| .:/....|ASCII &quot;But I guess, what does it matter&quot; 00007ffc:2f3ae878|00007ffc2f3ae180|..:/....|ASCII &quot;What am I to you?&quot; 00007ffc:2f3ae880|00007ffc2f3aeb00|..:/....|ASCII &quot;Everyone... Bubblegum... I&#39;m so dumb&quot; 00007ffc:2f3ae888|00007ffc2f3af5b0|..:/....|ASCII &quot;And you, Jake.&quot; 00007ffc:2f3ae890|0000000000000321|!.......| 00007ffc:2f3ae898|0000000000000000|........| 00007ffc:2f3ae8a0|206f6e20656b614d|Make no | 00007ffc:2f3ae8a8|21656b617473696d|mistake!| 00007ffc:2f3ae8b0|0000000000000000|........| 00007ffc:2f3ae8b8|0000000000000000|........| ...... 00007ffc:2f3ae990|0000000000000000|........| 00007ffc:2f3ae998|0000000000000000|........| 00007ffc:2f3ae9a0|00007ffc2f3af350|P.:/....|ASCII &quot;Do you look down on me &#39;cause I&#39;m younger?&quot; 00007ffc:2f3ae9a8|00007ffc2f3af480|..:/....|ASCII &quot;I&#39;m gonna sing a song that feels so real, it&#39;ll make this door break!&quot; 00007ffc:2f3ae9b0|00007ffc2f3af810|..:/....|ASCII &quot;Am I a joke, your knight, or your brother?&quot; 00007ffc:2f3ae9b8|00007ffc2f3af5b0|..:/....|ASCII &quot;And you, Jake.&quot; 上面一部分是歌词，下面一部分是索引这两个在 main 函数开头的赋值也很值得琢磨，说明此程序需要参数，这也就是为什么程序会出现段错误 .text:00000000004005A1 mov [rbp+var_1C94], edi ; 1C94 = argc .text:00000000004005A7 mov [rbp+var_1CA0], rsi ; 1CA0 = argv 下面就是主要的逻辑部分 v380 = &amp;v235; v379 = 1; v378 = 0; while ( 1 ) { v377 = *argv[1]; if ( !v377 ) break; if ( v379 &amp; 1 ) v378 *= v379; else v378 /= v379; v378 += (v377 - 32) * *((_DWORD *)v380 + 72); v380 = (__int64 *)v380[v377 - 65 + 32LL]; ++v379; ++argv[1]; } 暂且不用管v378的值；edb 指示出 v380 一开始指向 Everyone, Bubblegum, I’m so dumb，在网上可以找到一首名为 My Best Friends in the World 的歌曲，其开头就是 Everyone, Bubblegum, I’m so dumb，推测我们需要按照歌词的顺序“唱歌”，即选择正确的路径进行跳转Everyone, Bubblegum, I’m so dumb 的首地址为 7fffc2f3aeb00，而其下方第一个歌词索引的地址为 7fffc2f3aec00，两者相减为 0x100 = 256，除 8 等于 32，因此 v377 如果为 65 就选第一个索引，65 即 ‘A’，接下来就是选择题了 转自实验吧，原文作者实验吧ID faaaaaaaaaaaaaaa]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[recursive]]></title>
    <url>%2F2018%2F11%2F10%2Frecursive%2F</url>
    <content type="text"><![CDATA[文件是64位的elf程序，用Python写的。直接在kali下执行，返回一句“you wish it was that easy!”程序拖到IDA里，在Py_FrozenMain函数中看到取环境变脸“PYTHONINSPECT”和“PYTHONUNBUFFERED”。如果都有，会产生几个文件。在kali2里先设置环境变量，然后执行程序 root@kali:~/ctf# export PYTHONINSPECT=1 root@kali:~/ctf# export PYTHONUNBUFFERED=2 root@kali:~/ctf# ./recursive_python 在目录下会产生4个文件，也都是elf程序，执行一下 root@kali:~/ctf# ./unstep_34a4d33b Traceback (most recent call last): File &quot;./flag_1.py&quot;, line 4, in &lt;module&gt; IOError: [Errno 26] Text file busy: &#39;unstep_579c82e9&#39; root@kali:~/ctf# ./unstep_579c82e9 Traceback (most recent call last): File &quot;./flag_0.py&quot;, line 4, in &lt;module&gt; IOError: [Errno 26] Text file busy: &#39;unstep_f67baaeb&#39; root@kali:~/ctf# ./unstep_f67baaeb You wish it was that easy! 发现unstep_f67baaeb会输出报错，把他拖到IDA中，直接就可以看见flag 转自实验吧，原文作者实验吧ID b1uehat]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pinstore]]></title>
    <url>%2F2018%2F11%2F10%2Fpinstore%2F</url>
    <content type="text"><![CDATA[这是个Android逆向题，没有涉及到.so应该算简单的吧，但是我对那些加密的API还不熟。参考：https://github.com/Sinkmanu/CTF/blob/master/BSidesSF-2017-pinlock-150.javahttps://advancedpersistentjest.com/2017/02/14/writeup-pinlock-bsides-san-francisco/原来对于这种.db的数据库文件可以用sqlite3 xxx.db来查看。当然文本应该也可以查看但是不方便。 root@kali:~/repos/CTF/BSides-CTF-2017# wget https://github.com/youben11/BSides-San-Francisco-CTF-2017/raw/master/pinstore.apk root@kali:~/repos/CTF/BSides-CTF-2017# ls pinstore.apk root@kali:~/repos/CTF/BSides-CTF-2017# file pinstore.apk pinstore.apk: Java archive data (JAR) root@kali:~/repos/CTF/BSides-CTF-2017# unzip pinstore.apk root@kali:~/repos/CTF/BSides-CTF-2017# ls AndroidManifest.xml assets classes.dex META-INF pinstore.apk res resources.arsc root@kali:~/repos/CTF/BSides-CTF-2017# mkdir pinstore root@kali:~/repos/CTF/BSides-CTF-2017# mv AndroidManifest.xml assets classes.dex META-INF res resources.arsc pinstore/ root@kali:~/repos/CTF/BSides-CTF-2017# ls pinstore pinstore.apk root@kali:~/repos/CTF/BSides-CTF-2017# cd pinstore/ root@kali:~/repos/CTF/BSides-CTF-2017/pinstore# ls AndroidManifest.xml assets classes.dex META-INF res resources.arsc root@kali:~/repos/CTF/BSides-CTF-2017/pinstore# cd assets/ root@kali:~/repos/CTF/BSides-CTF-2017/pinstore/assets# ls pinlock.db README root@kali:~/repos/CTF/BSides-CTF-2017/pinstore/assets# cat README v1.0: - Pin database with hashed pins v1.1: - Added AES support for secret v1.2: - Derive key from pin [To-do: switch to the new database]root@kali:~/repos/CTF/BSides-CTF-2017/pinstore/assets# root@kali:~/repos/CTF/BSides-CTF-2017/pinstore/assets# which sqlite3 /usr/bin/sqlite3 root@kali:~/repos/CTF/BSides-CTF-2017/pinstore/assets# file pinlock.db pinlock.db: SQLite 3.x database, last written using SQLite version 3011000 root@kali:~/repos/CTF/BSides-CTF-2017/pinstore/assets# sqlite3 pinlock.db SQLite version 3.16.2 2017-01-06 16:32:41 Enter &quot;.help&quot; for usage hints. sqlite&gt; SELECT pin FROM pinDB; d8531a519b3d4dfebece0259f90b466a23efc57b sqlite&gt; SELECT entry FROM secretsDBv1; hcsvUnln5jMdw3GeI4o/txB5vaEf1PFAnKQ3kPsRW2o5rR0a1JE54d0BLkzXPtqB sqlite&gt; SELECT entry FROM secretsDBv2; Bi528nDlNBcX9BcCC+ZqGQo1Oz01+GOWSmvxRj7jg1g= sqlite&gt; SELECT * FROM secretsDBv2; 1|Bi528nDlNBcX9BcCC+ZqGQo1Oz01+GOWSmvxRj7jg1g= sqlite&gt; SELECT * FROM secretsDBv1; 1|hcsvUnln5jMdw3GeI4o/txB5vaEf1PFAnKQ3kPsRW2o5rR0a1JE54d0BLkzXPtqB 然后是writeup root@kali:~/repos/CTF/BSides-CTF-2017# wget https://raw.githubusercontent.com/Sinkmanu/CTF/master/BSidesSF-2017-pinlock-150.java root@kali:~/repos/CTF/BSides-CTF-2017# mv BSidesSF-2017-pinlock-150.java Bsides.java root@kali:~/repos/CTF/BSides-CTF-2017# javac Bsides.java root@kali:~/repos/CTF/BSides-CTF-2017# ls Bsides.class Bsides.java pinstore pinstore.apk root@kali:~/repos/CTF/BSides-CTF-2017# java Bsides.class Error: Could not find or load main class Bsides.class root@kali:~/repos/CTF/BSides-CTF-2017# java Bsides [*] SecretsDBv1 (encrypted): hcsvUnln5jMdw3GeI4o/txB5vaEf1PFAnKQ3kPsRW2o5rR0a1JE54d0BLkzXPtqB [*] SecretsDBv1 (decrypted): Here is what the data will look like [*] SecretsDB2 (encrypted): Bi528nDlNBcX9BcCC+ZqGQo1Oz01+GOWSmvxRj7jg1g= [+] Flag: ******** 用到的在线工具：https://www.onlinehashcrack.com/hash-identification.phphttp://hashtoolkit.com/reverse-hash/?hash=d8531a519b3d4dfebece0259f90b466a23efc57b 转自hebini.me 原链接]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debug]]></title>
    <url>%2F2018%2F11%2F10%2Fdebug%2F</url>
    <content type="text"><![CDATA[So they gave a 32-bit ELF stripped executable. Simply running the binary ./debug32 didn’t do nothing. I looked through the assembly in IDA and saw “Printing Flag” being printed somewhere.So the first and probably the last thing I needed to do was to jump to the function printing it. The address of the function as we can see is at 0x804849B. For this I used gdb. My first instinct was to set a breakpoint at main, then set the eip to the address of the required function and continue. This would print out the flag. But since this was a stripped binary(hence no symbols table), it didn’t recognise main as a valid breakpoint. So I set the breakpoint at __libc_start_main() function. This is the function which sets up the environment and then calls the main() function when the binary is run. So to carry out the required task, these were the commands I used: break __libc_start_main set $eip = 0x804849b continue This as expected printed out the flag! 转自hebini.me 原链接]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zer0llvm]]></title>
    <url>%2F2018%2F11%2F10%2Fzer0llvm%2F</url>
    <content type="text"><![CDATA[In this challenge we are given an obfuscation plugin for llvm and an obfuscated binary. The plugin accepts a 16-byte seed as a parameter and uses it for internal PRNG. Our goal is to analyze the binary and recover the seed from it. The binary is basically a big state machine. Here is start of the main function: .text:4004C0 main: ; DATA XREF: _start+1D .text:4004C0 push rbp .text:4004C1 mov rbp, rsp .text:4004C4 sub rsp, 4038Ch .text:4004CB mov dword ptr [rbp-4], 0 .text:4004D2 mov dword ptr [rbp-8], 46544330h .text:4004D9 mov dword ptr [rbp-0Ch], 4E52BCE7h .text:4004E0 .text:4004E0 main_switch: ; CODE XREF: .text:loc_7635AC .text:4004E0 mov eax, [rbp-0Ch] .text:4004E3 mov ecx, eax .text:4004E5 sub ecx, 8000DEEAh .text:4004EB mov [rbp-10h], eax .text:4004EE mov [rbp-14h], ecx .text:4004F1 jz loc_728049 .text:4004F7 jmp $+5 .text:4004FC .text:4004FC loc_4004FC: ; CODE XREF: .text:00000000004004F7 .text:4004FC mov eax, [rbp-10h] .text:4004FF sub eax, 8001EACAh .text:400504 mov [rbp-18h], eax .text:400507 jz loc_73E38A .text:40050D jmp $+5 .text:400512 .text:400512 loc_400512: ; CODE XREF: .text:000000000040050D .text:400512 mov eax, [rbp-10h] .text:400515 sub eax, 8003CC64h .text:40051A mov [rbp-1Ch], eax .text:40051D jz loc_5C0C95 .text:400523 jmp $+5 In pseudocode, it could be something like this: state = 0x4E52BCE7 main_switch: switch(state) { case 0x8000DEEA: goto loc_728049; case 0x8001EACA: goto loc_73E38A; case 0x8003CC64: goto loc_5C0C95; ... } loc_xxxxxx: // do something state = 0x8003CC64 goto main_switch Note that the state ids are sorted as signed 32-bit integers. Also, during the case probing, some intermediate data is written to the stack (i.e. [rbp-14h] and lower), but there are no further reads from that area. By running the binary and checking for system calls with strace we can see that it does not do anything useful. Let’s look at the llvm plugin to see how the seed is used. lib0opsPass.so The plugin is written in C++ and exports a bunch of functions. The main function of our interest is Oops::OopsFlattening::flatten(). Though it’s quite big, we can quickly locate interesting parts by looking at cross-references from crypto-related functions. First it calls prng_seed to seed its internal PRNG state: Oops::CryptoUtils::prng_seed(cryptoutils, &amp;seed_string); Then it uses the PRNG to generate 16 bytes: memset(&amp;key, 0, 0x20uLL); LODWORD(cryptoutils_) = llvm::ManagedStatic&lt;Oops::CryptoUtils&gt;::operator-&gt;(&amp;Oops::Oopscryptoutils, 0LL); Oops::CryptoUtils::get_bytes(cryptoutils_, &amp;key, 16); if ( crc32(&#39;FTC0&#39;, &amp;key, 3) != 0xF9E319A6 ) ... Note that the hardcoded crc32 check allows us to easily find the first 3 bytes of the generated key: 179, 197, 140. The key is then used to “scramble” values from a hardcoded array called plains: LODWORD(plains0) = plains[0]; LODWORD(v35) = llvm::ManagedStatic&lt;Oops::CryptoUtils&gt;::operator-&gt;(&amp;Oops::Oopscryptoutils, v33); v36 = plains0; v37 = Oops::CryptoUtils::scramble32(v35, plains0, &amp;key); ... v60 = counter++; plainsCUR = plains[v60]; LODWORD(v62) = llvm::ManagedStatic&lt;Oops::CryptoUtils&gt;::operator-&gt;(&amp;Oops::Oopscryptoutils, v59); v63 = Oops::CryptoUtils::scramble32(v62, plainsCUR, &amp;key); It’s not clear for now how these “scrambled” values are used later. IDA tells us that there are around 216 values in the array: .data:2345E0 ; _DWORD plains[65806] .data:2345E0 plains dd 0F6172961h, 0CB973739h, 904F3728h, 0DB7194B9h, 81E0B166h ... Probably it is possible to look at the LLVM-related code and see how exactly these values are used. But in the obfuscated binary there are not so many random-looking words. The only ones which come to mind are the state ids! Let’s log all the state ids passed to the main_switch. Here is a simple gdb script for it: $ cat &gt;cmd set confirm off set pagination off break *0x04004e3 commands p/x $eax cont end run $ gdb -x cmd -n ./0llvm &lt;/dev/null &gt;log $ head -30 log GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1 ... Reading symbols from ./0llvm...(no debugging symbols found)...done. Breakpoint 1 at 0x4004e3 Breakpoint 1, 0x00000000004004e3 in main () $1 = 0x4e52bce7 Breakpoint 1, 0x00000000004004e3 in main () $2 = 0x3ac545da Breakpoint 1, 0x00000000004004e3 in main () $3 = 0xff97c58e Breakpoint 1, 0x00000000004004e3 in main () $4 = 0xe83342dd $ tail log Breakpoint 1, 0x00000000004004e3 in main () $65789 = 0xf1dbf041 Breakpoint 1, 0x00000000004004e3 in main () $65790 = 0xdb9a21b8 Breakpoint 1, 0x00000000004004e3 in main () $65791 = 0xb02b5689 [Inferior 1 (process 10622) exited with code 027] (gdb) quit 65791 values! Quite close to 65801 found in IDA. The hypothesis seems to be true. But what does it give us now? Recovering key What we have found is that we have 216 pairs of plaintext/ciphertext under the “scramble32” function. Let’s look at it closer: __int64 __fastcall Oops::CryptoUtils::scramble32( Oops::CryptoUtils *this, unsigned int x, const char *key) { int v3; // ST20_4@1 int v4; // ST24_4@1 int v5; // ST20_4@1 v3 = AES_PRECOMP_TE3[(x ^ key[3])] ^ AES_PRECOMP_TE2[(BYTE1(x) ^ key[2])] ^ AES_PRECOMP_TE1[((x &gt;&gt; 16) ^ key[1])] ^ AES_PRECOMP_TE0[(BYTE3(x) ^ *key)]; v4 = AES_PRECOMP_TE3[(v3 ^ key[7])] ^ AES_PRECOMP_TE2[(BYTE1(v3) ^ key[6])] ^ AES_PRECOMP_TE1[((v3 &gt;&gt; 16) ^ key[5])] ^ AES_PRECOMP_TE0[(BYTE3(v3) ^ key[4])]; v5 = AES_PRECOMP_TE3[(v4 ^ key[11])] ^ AES_PRECOMP_TE2[(BYTE1(v4) ^ key[10])] ^ AES_PRECOMP_TE1[((v4 &gt;&gt; 16) ^ key[9])] ^ AES_PRECOMP_TE0[(BYTE3(v4) ^ key[8])]; return AES_PRECOMP_TE3[(v5 ^ key[15])] ^ AES_PRECOMP_TE2[(BYTE1(v5) ^ key[14])] ^ AES_PRECOMP_TE1[((v5 &gt;&gt; 16) ^ key[13])] ^ AES_PRECOMP_TE0[(BYTE3(v5) ^ key[12])] ^ ((key[2] &lt;&lt; 8) | (key[1] &lt;&lt; 16) | (*key &lt;&lt; 24) | key[3]); } Interesting, it is related to the AES block cipher. The AES_PRECOMP_TE tables map 8-bit values to 32-bit values. Possibly these tables implement MixColumns, or even together with SBoxes and xors. Let’s compose them with inverse of MixColumns (aes.py): from aes import AES A = AES() for i in xrange(4): for x, t in enumerate(AES_PRECOMP_TE[i]): t = [BYTE3(t), BYTE2(t), BYTE1(t), BYTE0(t)] t2 = A.mixColumn(list(t), isInv=True) print t2 print $ python precomp.py [99, 0, 0, 0] [124, 0, 0, 0] [119, 0, 0, 0] [123, 0, 0, 0] [242, 0, 0, 0] [107, 0, 0, 0] ... This is the AES SBox applied to one of the bytes! It means that AES_PRECOMP_TEi = MixColumns(SBox(x) &lt;&lt; 8*i). Therefore scramble32 is a 4-round iteration of XorKey, SubBytes, MixColumn followed by another XorKey. How do we recover the key? Recall that we know key[0], key[1], key[2] from a CRC32 check. We can guess one-byte key[3] and bypass the first round easily. Luckily, the last whitening key is the same as the first one: with the same guess we can decrypt the last round aswell! By moving the keys through the linear layers and decrypring the linear layers, we arrive at two rounds: XK | SB | MC | XK | SB | XK. Let’s use impossible polytopes. Assume that we have three plaintexts of the form (it is probable that we have such among the 216 texts by birthday paradox): X1 = (x1, a, b, c) X2 = (x2, a, b, c) X3 = (x3, a, b, c) We will study how a difference tuple (X1 ⊕ X2, X1 ⊕ X3) propagates through the cipher. Since it is a difference, it propagates through the key addition untouched. After SubBytes a set of possible difference tuples expands up to 28 elements. Since MixColumn is linear, any difference (x, y) propagates to (MixColumn(x), MixColumn(y)). Therefore, before the last SubBytes layer, we have only 28 possible differences, which can easily be precomputed. Thus, we can recover the last key byte-by-byte: guess byte of the key, decrypt through S-Box, check difference tuple (note that the middle XK does not affect it). We are truncating the differences of 32-bit values to differences of 8-bit values, but this is fine since we look at pairs of differences: 28 possible pairs out of 216 give us 1/28 filtration for each key byte. By tracking the first guessed key byte, we can ensure that only the correct key survives. The full attack implementation is available here. Recovering Seed We have recovered the key, but the flag is the PRNG seed! How to recover it? The code for stream generation is as follows: // in Oops::CryptoUtils::encrypt(Oops::CryptoUtils *this, unsigned __int8 *dst, unsigned __int8 *nonce, unsigned __int8 *seed) memset(dst, 0, 0x10uLL); v5 = *(nonce_ + 1); *buf = *nonce_; *buf2 = v5; for ( i = 0; i &lt;= 15; ++i ) { seedbyte = seed_[i]; for ( j = 0; j &lt;= 7; ++j ) { if ( seedbyte &amp; 1 ) { for ( k = 0; k &lt;= 15; ++k ) dst[k] ^= buf[k]; } seedbyte = seedbyte &gt;&gt; 1; for ( l = 0; l &lt;= 15; ++l ) buf[l] = TABLE[buf[l]]; } } Here TABLE is an 8-bit nonlinear S-Box. Nonce is constant and hardcoded (note that it is increased by 1 before calling encrypt, as a big-endian number, see Oops::CryptoUtils::inc_ctr): // in Oops::CryptoUtils::prng_seed(struct CryptoUtils *cryptoutils, __int64 a2) noncebuf = cryptoutils-&gt;nonce; *noncebuf = 0xD7C59B4DFFD1E010LL; *(noncebuf + 1) = 0x20C7C17B250E019ALL; Though TABLE is nonlinear, the buf array is updated independently and therefore we can see its different versions as constants. Mixing of buf and seed is done linearly, so we can recover the seed from the PRNG output (which is the AES key) by simple linear algebra: from sage.all import * from struct import pack, unpack def tobin(x, n): return tuple(map(int, bin(x).lstrip(&quot;0b&quot;).rjust(n, &quot;0&quot;))) def frombin(v): return int(&quot;&quot;.join(map(str, v)), 2 ) def tobinvec(v): return sum( [tobin(c, 8) for c in v], () ) PRNG_OUT = [179, 197, 140, 9, 31, 61, 9, 48, 214, 74, 172, 159, 200, 11, 185, 236] TABLE = [0x0ED,0x67,0x7F,0x0F6,0x0C7,0x9A,0x24,0x12,0x0BA,0x83,0x49,0x0DB,0x13,0x0BF,0x61,0x0B0,0x0FF,0x69,0x80,0x0EC,0x0DE,0x4,0x63,0x0C4,0x96,0x73,0x1B,0x6E,0x0A6,0x9E,0x87,0x4B,0x0FC,0x10,0x2A,0x0C3,0x5C,0x2E,0x36,0x0B2,0x0DF,0x0E3,0x90,0x0FE,0x1A,0x0F,0x1C,0x84,0x1,0x15,0x3A,0x85,0x0A5,0x57,0x3F,0x6D,0x0F5,0x4A,0x0A,0x0D6,0x9F,0x64,0x0B5,0x0F7,0x8F,0x99,0x68,0x4D,0x17,0x0F9,0x0EE,0x0F0,0x3,0x6,0x4C,0x0BD,0x58,0x33,0x0A9,0x0DC,0x3C,0x0A3,0x3B,0x0D1,0x0BB,0x28,0x0F4,0x0B9,0x0CF,0x47,0x0A0,0x6A,0x0C2,0x19,0x0B,0x97,0x81,0x35,0x91,0x7C,0x5D,0x7A,0x48,0x2B,0x41,0x0D9,0x0CB,0x6F,0x56,0x8D,0x5A,0x0C5,0x3E,0x0D8,0x0C0,0x60,0x1F,0x9,0x0CA,0x7B,0x25,0x0E7,0x0AE,0x0F2,0x77,0x0FA,0x3D,0x50,0x0E2,0x4F,0x0C9,0x2C,0x53,0x45,0x0C1,0x0E9,0x46,0x0D,0x70,0x8A,0x0A1,0x0D5,0x94,0x92,0x88,0x95,0x9D,0x26,0x9B,0x0E4,0x5,0x44,0x11,0x2D,0x7,0x1E,0x0A4,0x38,0x0E1,0x0A8,0x52,0x89,0x0AF,0x40,0x72,0x0E5,0x0B4,0x7E,0x51,0x6C,0x0FB,0x76,0x62,0x0D4,0x8,0x9C,0x54,0x5B,0x75,0x29,0x0C6,0x66,0x0DA,0x0FD,0x14,0x86,0x78,0x16,0x0B6,0x8B,0x39,0x0E6,0x0B7,0x1D,0x0D3,0x18,0x0A7,0x30,0x0E8,0x23,0x37,0x7D,0x82,0x0BE,0x34,0x0C,0x55,0x0D0,0x0EF,0x0,0x0CD,0x0AC,0x0A2,0x4E,0x0B3,0x0AB,0x31,0x8E,0x21,0x0E0,0x22,0x74,0x5E,0x8C,0x32,0x0F8,0x0EB,0x2F,0x79,0x0F1,0x42,0x0C8,0x0DD,0x0CE,0x65,0x27,0x5F,0x20,0x0B8,0x0AA,0x0AD,0x71,0x6B,0x0D2,0x0EA,0x0BC,0x0E,0x0CC,0x98,0x2,0x59,0x43,0x0B1,0x93,0x0D7,0x0F3,] # note 0x20... -&gt; 0x21 nonce = pack(&quot;&lt;QQ&quot;, 0xD7C59B4DFFD1E010, 0x21C7C17B250E019A) cols = [map(ord, nonce)] for i in xrange(127): v = [TABLE[c] for c in cols[-1]] cols.append(v) cols = [vector(GF(2), tobinvec(v)) for v in cols] target = vector(GF(2), tobinvec(PRNG_OUT)) m = matrix(GF(2), 128, len(cols)) for x, c in enumerate(cols): m.set_column(x, c) try: sol = m.solve_right(target) except ValueError: print &quot;NO SOLUTION&quot; quit() print &quot;SOL&quot;, sol res = &quot;&quot; for i in xrange(0, 128, 8): res += chr(frombin(sol[i:i+8][::-1])) print &quot;flag{%s}&quot; % res 转自hebini.me 原链接]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py137]]></title>
    <url>%2F2018%2F11%2F10%2Fpy137%2F</url>
    <content type="text"><![CDATA[0CTF的题The archive contains a compiled Python file crypt.pyc and an encrypted flag file encrypted_flag.As the description states, the compiled Python code is mangled. Using uncompyle6 gives an error: $ uncompyle6 crypt.pyc # uncompyle6 version 2.9.9 # Python bytecode 2.7 (62211) # Decompiled from: Python 2.7.13 (default, Jan 19 2017, 14:48:08) # [GCC 6.3.0 20170118] # Embedded file name: /Users/hen/Lab/0CTF/py/crypt.py # Compiled at: 2017-01-06 01:08:38 Traceback (most recent call last): File &quot;/usr/local/bin/uncompyle6&quot;, line 11, in &lt;module&gt;; sys.exit(main_bin()) File &quot;/usr/local/lib/python2.7/dist-packages/uncompyle6/bin/uncompile.py&quot;, line 163, in main_bin **options) File &quot;/usr/local/lib/python2.7/dist-packages/uncompyle6/main.py&quot;, line 145, in main uncompyle_file(infile, outstream, showasm, showast, showgrammar) File &quot;/usr/local/lib/python2.7/dist-packages/uncompyle6/main.py&quot;, line 72, in uncompyle_file is_pypy=is_pypy, magic_int=magic_int) File &quot;/usr/local/lib/python2.7/dist-packages/uncompyle6/main.py&quot;, line 46, in uncompyle is_pypy=is_pypy) File &quot;/usr/local/lib/python2.7/dist-packages/uncompyle6/semantics/pysource.py&quot;, line 2254, in deparse_code tokens, customize = scanner.ingest(co, code_objects=code_objects, show_asm=showasm) File &quot;/usr/local/lib/python2.7/dist-packages/uncompyle6/scanners/scanner2.py&quot;, line 230, in ingest pattr = free[oparg] IndexError: tuple index out of range Let’s turn to a Python disassembler to dump the file structure. Because the opcodes are messed up, let’s comment out the part of the disassembler code that prints out the bytecode (dis.disassemble(code)). It was also necessary to comment out some failing timestamp analysis code, which was not important. Running the disassembler over the challenge file gives the following result: $ python dec.py crypt.pyc magic 03f30d0a moddate 66346f58 (0) code argcount 0 nlocals 0 stacksize 2 flags 0040 code 990000990100860000910000990200880000910100990300880000910200 99010053 consts -1 None code argcount 1 nlocals 6 stacksize 3 flags 0043 code 990100680100990200680200990300680300610100990400469905002761 020061010027610300279906004627990500276102009906004627990700 276804009b00006001006104008301006805006105006002006100008301 0053 consts None &#39;!@#$%^&amp;amp;*&#39; &#39;abcdefgh&#39; &#39;&lt;&gt;{}:&quot;&#39; 4 &#39;|&#39; 2 &#39;EOF&#39; names (&#39;rotor&#39;, &#39;newrotor&#39;, &#39;encrypt&#39;) varnames (&#39;data&#39;, &#39;key_a&#39;, &#39;key_b&#39;, &#39;key_c&#39;, &#39;secret&#39;, &#39;rot&#39;) freevars () cellvars () filename &#39;/Users/hen/Lab/0CTF/py/crypt.py&#39; name &#39;encrypt&#39; firstlineno 2 lnotab 00010601060106012e010f01 code argcount 1 nlocals 6 stacksize 3 flags 0043 code 990100680100990200680200990300680300610100990400469905002761 020061010027610300279906004627990500276102009906004627990700 276804009b00006001006104008301006805006105006002006100008301 0053 consts None &#39;!@#$%^&amp;amp;*&#39; &#39;abcdefgh&#39; &#39;&lt;&gt;{}:&quot;&#39; 4 &#39;|&#39; 2 &#39;EOF&#39; names (&#39;rotor&#39;, &#39;newrotor&#39;, &#39;decrypt&#39;) varnames (&#39;data&#39;, &#39;key_a&#39;, &#39;key_b&#39;, &#39;key_c&#39;, &#39;secret&#39;, &#39;rot&#39;) freevars () cellvars () filename &#39;/Users/hen/Lab/0CTF/py/crypt.py&#39; name &#39;decrypt&#39; firstlineno 10 lnotab 00010601060106012e010f01 names (&#39;rotor&#39;, &#39;encrypt&#39;, &#39;decrypt&#39;) varnames () freevars () cellvars () filename &#39;/Users/hen/Lab/0CTF/py/crypt.py&#39; name &#39;&lt;module&gt;&#39; firstlineno 1 lnotab 0c010908 There is lots of interesting info that we can glean from this output (and by reading the Python opcode documentation and source code): this file uses the rotor library and defines 2 methods - encrypt and decrypt encrypt and decrypt method bodies look almost identical; naturally we need to look at decrypt closely rotor functions newrotor and decrypt are used there are some kinds of key variables key_a, key_b and key_c being used, and also something called a secret (a decryption key?) there are some interesting constants embedded in the code, including !@#$%^&amp;*, abcdefgh, and &lt;&gt;{}:&quot;; do these correspond to key_a through _c? In order to start analyzing the code let’s create our own decryption function and decompile it. It would likely have the following components: a parameter passed in a result string returned some constant initialization some operations to create a decryption key code to decrypt the dataHere’s a first version of that code. We will make some assumptions about how the variables in the challenge file (data, secret, etc.) are actually used: import rotor def decrypt(data): key_a = &#39;!@#$%^&amp;*&#39; key_b = &#39;abcdefgh&#39; key_c = &#39;&lt;&gt;{}:&quot;&#39; secret = key_a + key_b + key_c rot = rotor.newrotor(secret) return rot.decrypt(data) enc = open(&quot;encrypted_flag&quot;, &quot;rb&quot;).read() print decrypt(enc) Let’s re-enable opcode analysis in the disassembler and run it over this new file: $ python -c &quot;import py_compile;py_compile.compile(&#39;ex.py&#39;);&quot;; python dec.py ex.pyc magic 03f30d0a moddate e2f2cf58 (0) code argcount 0 nlocals 0 stacksize 3 flags 0040 code 6400006401006c00005a00006402008400005a0100650200640300640400 8302006a03008300005a0400650100650400830100474864010053 1 0 LOAD_CONST 0 (-1) 3 LOAD_CONST 1 (None) 6 IMPORT_NAME 0 (rotor) 9 STORE_NAME 0 (rotor) 3 12 LOAD_CONST 2 (&lt;code object decrypt at 0x7f664ada8530, file &quot;ex.py&quot;, line 3&gt;) 15 MAKE_FUNCTION 0 18 STORE_NAME 1 (decrypt) 13 21 LOAD_NAME 2 (open) 24 LOAD_CONST 3 (&#39;encrypted_flag&#39;) 27 LOAD_CONST 4 (&#39;rb&#39;) 30 CALL_FUNCTION 2 33 LOAD_ATTR 3 (read) 36 CALL_FUNCTION 0 39 STORE_NAME 4 (enc) 15 42 LOAD_NAME 1 (decrypt) 45 LOAD_NAME 4 (enc) 48 CALL_FUNCTION 1 51 PRINT_ITEM 52 PRINT_NEWLINE 53 LOAD_CONST 1 (None) 56 RETURN_VALUE consts -1 None code argcount 1 nlocals 6 stacksize 2 flags 0043 code 6401007d01006402007d02006403007d03007c01007c0200177c0300177d 04007400006a01007c04008301007d05007c05006a02007c000083010053 4 0 LOAD_CONST 1 (&#39;!@#$%^&amp;amp;*&#39;) 3 STORE_FAST 1 (key_a) 5 6 LOAD_CONST 2 (&#39;abcdefgh&#39;) 9 STORE_FAST 2 (key_b) 6 12 LOAD_CONST 3 (&#39;&lt;&gt;{}:&quot;&#39;) 15 STORE_FAST 3 (key_c) 8 18 LOAD_FAST 1 (key_a) 21 LOAD_FAST 2 (key_b) 24 BINARY_ADD 25 LOAD_FAST 3 (key_c) 28 BINARY_ADD 29 STORE_FAST 4 (secret) 10 32 LOAD_GLOBAL 0 (rotor) 35 LOAD_ATTR 1 (newrotor) 38 LOAD_FAST 4 (secret) 41 CALL_FUNCTION 1 44 STORE_FAST 5 (rot) 11 47 LOAD_FAST 5 (rot) 50 LOAD_ATTR 2 (decrypt) 53 LOAD_FAST 0 (data) 56 CALL_FUNCTION 1 59 RETURN_VALUE consts None &#39;!@#$%^&amp;amp;*&#39; &#39;abcdefgh&#39; &#39;&lt;&gt;{}:&quot;&#39; names (&#39;rotor&#39;, &#39;newrotor&#39;, &#39;decrypt&#39;) varnames (&#39;data&#39;, &#39;key_a&#39;, &#39;key_b&#39;, &#39;key_c&#39;, &#39;secret&#39;, &#39;rot&#39;) freevars () cellvars () filename &#39;ex.py&#39; name &#39;decrypt&#39; firstlineno 3 lnotab 00010601060106020e020f01 &#39;encrypted_flag&#39; &#39;rb&#39; names (&#39;rotor&#39;, &#39;decrypt&#39;, &#39;open&#39;, &#39;read&#39;, &#39;enc&#39;) varnames () freevars () cellvars () filename &#39;ex.py&#39; name &#39;&lt;module&gt;&#39; firstlineno 1 lnotab 0c02090a1502 Disassembler gives us more useful information: most instructions are either a single opcode, or an opcode and a 2-byte parameter parameter offsets are 0-based (duh) Python instructions heavily use the stack - data is pushed on it and many opcodes process the top one or two items on the stack at least one opcode (53 - RETURN_VALUE) was not obfuscated - it’s the same in the code for the challenge some of our guesses about names and meanings of different variables worked - names and varnames fields match corresponding challenge file fields perfectly Now we will break down the challenge binary opcode stream into individual operations and try to match them to instructions in our decryption code. Looks like rotor call functionality can be matched directly (assuming we are correct about secret being the decryption key): 990100 680100 990200 680200 990300 680300 610100 990400 46 990500 27 610200 610100 27 610300 27 990600 46 27 990500 27 610200 990600 46 27 990700 27 680400 STORE_NAME 4 (secret) 9b0000 LOAD_GLOBAL 0 (rotor) 600100 LOAD_ATTR 1 (newrotor) 610400 LOAD_FAST 4 (secret) 830100 CALL_FUNCTION 1 680500 STORE_NAME 5 (rot) 610500 LOAD_FAST 5 (rot) 600200 LOAD_ATTR 2 (decrypt) 610000 LOAD_FAST 0 (data) 830100 CALL_FUNCTION 1 53 RETURN_VALUE This gives us the following translation for opcodes: 68 - STORE_NAME 9b - LOAD_GLOBAL 60 - LOAD_ATTR 61 - LOAD_FAST 83 - CALL_FUNCTION (was not obfuscated) Also it looks like 99 is actually LOAD_CONST. Let’s fill in this information: 990100 LOAD_CONST 1 (&#39;!@#$%^&amp;amp;*&#39;) 680100 STORE_NAME 1 (key_a) 990200 LOAD_CONST 2 (&#39;abcdefgh&#39;) 680200 STORE_NAME 2 (key_b) 990300 LOAD_CONST 3 (&#39;&lt;&gt;{}:&quot;&#39;) 680300 STORE_NAME 3 (key_c) 610100 LOAD_FAST 1 (key_a) 990400 LOAD_CONST 4 (4) 46 990500 LOAD_CONST 5 (&#39;|&#39;) 27 610200 LOAD_FAST 2 (key_b) 610100 LOAD_FAST 1 (key_a) 27 610300 LOAD_FAST 3 (key_c) 27 990600 LOAD_CONST 6 (2) 46 27 990500 LOAD_CONST 5 (&#39;|&#39;) 27 610200 LOAD_FAST 2 (key_b) 990600 LOAD_CONST 6 (2) 46 27 990700 LOAD_CONST 7 (&#39;EOF&#39;) 27 680400 STORE_NAME 4 (secret) 9b0000 LOAD_GLOBAL 0 (rotor) 600100 LOAD_ATTR 1 (newrotor) 610400 LOAD_FAST 4 (secret) 830100 CALL_FUNCTION 1 680500 STORE_NAME 5 (rot) 610500 LOAD_FAST 0 (rot) 600200 LOAD_ATTR 2 (decrypt) 610000 LOAD_FAST 0 (data) 830100 CALL_FUNCTION 1 53 RETURN_VALUE This looks very promising. We only need to find what kinds of manipulations are done on the encryption key and we will be done.Opcodes 46 and 27 are the remaining unknowns. 46 works on a string and a numeric argument, and 27 works on 2 strings. Essentially we have the following expression: secret = (key_a OP46 4) OP27 &#39;|&#39; OP27 ((key_b OP27 key_a OP27 key_c) OP46 2) OP27 &#39;|&#39; OP27 (key_b OP46 2) OP27 &#39;EOF&#39; After some trial and error with our code, we find that 46 is a multiplication operation, and 27 is an addition. This gives us the following final version of decryption code: import rotor def decrypt(data): key_a = &#39;!@#$%^&amp;*&#39; key_b = &#39;abcdefgh&#39; key_c = &#39;&lt;&gt;{}:&quot;&#39; secret = key_a*4 + &#39;|&#39; + (key_b+key_a+key_c)*2 + &#39;|&#39; + key_b*2 + &#39;EOF&#39; rot = rotor.newrotor(secret) return rot.decrypt(data) i = open(&quot;encrypted_flag&quot;, &quot;rb&quot;).read() print decrypt(i) Running it gives us the flag 转自hebini.me 原链接]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[520windows3]]></title>
    <url>%2F2018%2F11%2F10%2F520windows3%2F</url>
    <content type="text"><![CDATA[题目说明：运行后提示按流程来，先拉进IDA里按F5看看：原来Key是通过CMD参数给出。然后是这个，很显眼的反调试：先干掉他：改成无论如何都继续程序而不退出：保存继续分析知：关键验证在这里：比对两个数组，不等就：输入的Key会经过好几个函数的加密看起来静态分析代码再手动写解密程序是不可能了，只能动态调试看看关键地方里的v16和v86是何方神圣了。(其实前面的反调试已经暗示了这道题要用动态调试)在上面提到的关键比较处下断点，然后选择调试器，设置了几个不同的参数开始调试。发现：v16是静态的，v86根据输入key不同而改变所以，就去看看v16所在地址是什么呗：看来不是明文，先拿去解密网站试试：www.cmd5.com结果没报错，所以key就是hello 转自CSDN，原连接]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[520app3]]></title>
    <url>%2F2018%2F11%2F10%2F520app3%2F</url>
    <content type="text"><![CDATA[这道题在之前比赛的时候也遇到过，当时一脸懵逼……(虽然现在也是差不多首先先看看怎么动态调试so，这是教程http://blog.csdn.net/feibabeibei_beibei/article/details/52740212按着教程，把Debugger option的那三个选项给选上，之后也不用取消掉然后断在linker之后根据偏移找到.init_proc本来想跟下去，看看怎么解密数据的，但是报了个error，我也懒得跟了。。。按F9，然后断下来之后，所有数据都解密出来了，这个时候可以用dd 把现在的so给dump下来本来是可以修复so，然后静态看出flag的，但是我也不会修。。。。。所以直接在动态调试的代码上面看，因为在原始的so里面也知道JNI_Onload的偏移，所以这个时候可以根据偏移来找到JNI_OnloadJNI_Onload大概就是这个样子，这个也是大概的套路然后红色那里其实是J_create，创建了一个线程，sub_F8C是一个函数，不断的接收东西，但是只接收，什么也不处理所以关键就在unk_711C那里这里说明一下，上面那个图片是自己修了一半的半成品。。。所以变成那样。。。下面这个图片是动态调试的，每个人的地址都可能不同这里有三个地址，第一个地址是指向字符串upload 的，第二个是指向字符串(Ljava/lang/String;)I ，第三个地址才是真正的地址反编译之后会看到类似这样的东西，但是这里是逆向出来是connect之类的字符串真正比较可疑的地方是这里，这里可以解出来两个字符串，第一个大概是帐号，第二个有Phone的才是flag，然后顺便看了下面，大概是调用了别的so，然后用浏览器来传数据的样子做题的话到这里就可以了，如果是真正逆向的话肯定就不止这样了 转自实验吧，原文作者实验吧ID charlie_li]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[defcamp]]></title>
    <url>%2F2018%2F11%2F10%2Fdefcamp%2F</url>
    <content type="text"><![CDATA[IDA反汇编调试出main函数链表中一共10个元素。每个元素16字节大小，前4个字节存储1到10。从第5个字节开始存储序号值+109。对于输入s，如果sub_40074D返回值为0，则正确。 v6=v9 5 2 7 2 5 6 v6的初始值为0，v4每次循环初始值为0。当输入的字母与链表中序号值+109相等时，才会被赋值为序号值。即v4=5 2 7 2 5 6 输入字母的ASCII码应为 114 111 116 111 114 115 对应ASCII码得出答案 转自实验吧，原文作者实验吧ID 南风如何知我意]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[catalyst-system]]></title>
    <url>%2F2018%2F11%2F10%2Fcatalyst-system%2F</url>
    <content type="text"><![CDATA[将可执行文件放在kali虚拟机中运行发现出现了欢迎的一段文字以及漫长的一个loading…..就这样？不甘心，于是把可执行文件丢ida里逆向，根据string(Welcome to Catalyst systems)定位到汇编代码位置：按F5生成c代码，可以看到整个可执行文件的结构： puts(&quot;\x1B[0mWelcome to Catalyst systems&quot;); printf(&quot;Loading&quot;, a2); fflush(stdout); for ( i = 0; i &lt;= 29; ++i ) { v4 = rand(); sleep(v4 % (3 * i + 1)); putchar(46); fflush(stdout); } putchar(10); printf(&quot;Username: &quot;); __isoc99_scanf(&quot;%s&quot;, v8); printf(&quot;Password: &quot;, v8); __isoc99_scanf(&quot;%s&quot;, v7); printf(&quot;Logging in&quot;, v7); fflush(stdout); for ( j = 0; j &lt;= 29; ++j ) { v5 = rand(); sleep(v5 % (j + 1)); putchar(46); fflush(stdout); } putchar(10); sub_400C9A((__int64)v8); sub_400CDD(v8); sub_4008F7((__int64)v8); sub_400977(v8, v7); sub_400876((__int64)v8, (__int64)v7); 可以发现在loading之后有一个循环结构，而且用了sleep，于是把这个29用ida的patch改为2，此外在输入了用户名和密码之后还有一个没什么用的循环结构，同理改为2。这样就不会再有那么漫长的无谓等待了。把patch之后的可执行文件放到kali下执行： Welcome to Catalyst systems Loading... Username: test Password: test Logging in... invalid username or password 可以看到有对用户名和密码的验证逻辑于是看主函数中调用的几个函数。在查看sub_400CDD(v8)函数的时候发现内部有对用户名的验证： signed __int64 __fastcall sub_400CDD(unsigned int *a1) { signed __int64 result; // rax __int64 v2; // [rsp+10h] [rbp-20h] __int64 v3; // [rsp+18h] [rbp-18h] __int64 v4; // [rsp+20h] [rbp-10h] v4 = *a1; v3 = a1[1]; v2 = a1[2]; if ( v4 - v3 + v2 != 1550207830 || v3 + 3 * (v2 + v4) != 12465522610LL || (result = 3651346623716053780LL, v2 * v3 != 3651346623716053780LL) ) { puts(&quot;invalid username or password&quot;); exit(0); } return result; } 可以整理出三个公式： v4 - v3 + v2 = 1550207830 v3 + 3 * (v2 + v4) = 12465522610LL v2 * v3 = 3651346623716053780LL 这里就可以通过计算v2、v3和v4来得到username。在sub_400977(v8, v7)方法中有对password进行验证的逻辑： for ( i = 0; *((_BYTE *)a2 + i); ++i ) { if ( (*((_BYTE *)a2 + i) &lt;= 96 || *((_BYTE *)a2 + i) &gt; 122) &amp;&amp; (*((_BYTE *)a2 + i) &lt;= 64 || *((_BYTE *)a2 + i) &gt; 90) &amp;&amp; (*((_BYTE *)a2 + i) &lt;= 47 || *((_BYTE *)a2 + i) &gt; 57) ) { puts(&quot;invalid username or password&quot;); exit(0); } } srand(a1[1] + *a1 + a1[2]); v2 = *a2; if ( v2 - rand() != 1441465642 ) { puts(&quot;invalid username or password&quot;); exit(0); } v3 = a2[1]; if ( v3 - rand() != 251096121 ) { puts(&quot;invalid username or password&quot;); exit(0); } v4 = a2[2]; if ( v4 - rand() != -870437532 ) { puts(&quot;invalid username or password&quot;); exit(0); } v5 = a2[3]; if ( v5 - rand() != -944322827 ) { puts(&quot;invalid username or password&quot;); exit(0); } v6 = a2[4]; if ( v6 - rand() != 647240698 ) { puts(&quot;invalid username or password&quot;); exit(0); } v7 = a2[5]; if ( v7 - rand() != 638382323 ) { puts(&quot;invalid username or password&quot;); exit(0); } v8 = a2[6]; if ( v8 - rand() != 282381039 ) { puts(&quot;invalid username or password&quot;); exit(0); } v9 = a2[7]; if ( v9 - rand() != -966334428 ) { puts(&quot;invalid username or password&quot;); exit(0); } v10 = a2[8]; if ( v10 - rand() != -58112612 ) { puts(&quot;invalid username or password&quot;); exit(0); } v11 = a2[9]; v12 = v11 - rand(); result = v12; if ( v12 != 605226810 ) { puts(&quot;invalid username or password&quot;); exit(0); } 可以看到方法中使用了用户名几个字段的和作为随机数种子，而且后面的password的计算也需要随机数参与计算，所以这里我们不能直接通过静态分析来得出结论。但是我们也知道只要随机数种子固定，每次的随机都是伪随机，所以我们可以编写程序来计算密码。代码来自https://0xd13a.github.io/ctfs/alexctf2017/catalyst-system/ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; int main() { unsigned int rax3, rax4, rax5; char u[12]; char p[40]; char key[] = {0x42, 0x13, 0x27, 0x62, 0x41, 0x35, 0x6b, 0x0f, 0x7b, 0x46, 0x3c, 0x3e, 0x67, 0x0c, 0x08, 0x59, 0x44, 0x72, 0x36, 0x05, 0x0f, 0x15, 0x54, 0x43, 0x38, 0x17, 0x1d, 0x18, 0x08, 0x0e, 0x5c, 0x31, 0x21, 0x16, 0x02, 0x09, 0x18, 0x14, 0x54, 0x59}; rax4 = (0x2e700c7b2L - 0x5c664b56L * 3) / 4; rax5 = 0x32ac30689a6ad314L / rax4; rax3 = 0x5c664b56L - rax5 + rax4; ((unsigned int*)u)[0] = rax3; ((unsigned int*)u)[1] = rax4; ((unsigned int*)u)[2] = rax5; printf(&quot;username: %.*s\n&quot;, sizeof(u), u); srand(rax3 + rax4 + rax5); ((unsigned int*)p)[0] = 0x55eb052a + rand(); ((unsigned int*)p)[1] = 0x0ef76c39 + rand(); ((unsigned int*)p)[2] = 0xcc1e2d64 + rand(); ((unsigned int*)p)[3] = 0xc7b6c6f5 + rand(); ((unsigned int*)p)[4] = 0x26941bfa + rand(); ((unsigned int*)p)[5] = 0x260cf0f3 + rand(); ((unsigned int*)p)[6] = 0x10d4caef + rand(); ((unsigned int*)p)[7] = 0xc666e824 + rand(); ((unsigned int*)p)[8] = 0xfc89459c + rand(); ((unsigned int*)p)[9] = 0x2413073a + rand(); printf(&quot;password: %.*s\n&quot;, sizeof(p), p); printf(&quot;flag: ALEXCTF{&quot;); for (int i = 0; i &lt; sizeof(p); i++) { printf(&quot;%c&quot;, p[i] ^ key[i]); } printf(&quot;}\n&quot;); } $ gcc -o solve solve.c &amp;&amp; ./solve username: catalyst_ceo password: sLSVpQ4vK3cGWyW86AiZhggwLHBjmx9CRspVGggj flag: ALEXCTF{1_t41d_y0u_y0u_ar3__gr34t__reverser__s33} 转自实验吧，原文作者实验吧ID vincentvan]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CFG to C]]></title>
    <url>%2F2018%2F11%2F10%2FCFG-to-C%2F</url>
    <content type="text"><![CDATA[这是at&amp;t的汇编指令 图1中，从流程图中可以看出是一个循环，从判断条件可以看出是是于0进行比较，所以选B。 图2中，从流程图可以明显看出是一个if..else…形式，而且没有循环，所以选择C。 图3中，从流程图可以看出是一个循环，所以选D。 直接知道选择A。 所以最后的顺序是BCDA。 转自实验吧，原文作者实验吧ID Roach]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Byte Code]]></title>
    <url>%2F2018%2F11%2F10%2FByte-Code%2F</url>
    <content type="text"><![CDATA[题目提供了.class文件用jd-gui打开直接得到源码，接下来就是简单的代码审计了附源码 import java.io.Console; import java.io.PrintStream; class Authenticator { public static char[] key; public static void main(String[] paramArrayOfString) { key = new char[10]; key[0] = &#39;A&#39;; key[1] = &#39;o&#39;; key[2] = &#39;J&#39;; key[3] = &#39;k&#39;; key[4] = &#39;V&#39;; key[5] = &#39;h&#39;; key[6] = &#39;L&#39;; key[7] = &#39;w&#39;; key[8] = &#39;U&#39;; key[9] = &#39;R&#39;; Console localConsole = System.console(); String str = &quot;&quot;; while (!str.equals(&quot;ThisIsth3mag1calString4458&quot;)) { str = localConsole.readLine(&quot;Enter password:&quot;, new Object[0]); } for (int i = 0; i &lt; key.length; i++) { System.out.print(key[i]); } System.out.println(&quot;&quot;); } }]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bitwise]]></title>
    <url>%2F2018%2F11%2F10%2Fbitwise%2F</url>
    <content type="text"><![CDATA[分析源码之后暴力跑吧 arr = [193, 35, 9, 33, 1, 9, 3, 33, 9, 225] flag=&quot;&quot; for j in arr: for i in range(1,126): char =chr(i) c=(((ord(char) &lt;&lt; 5) | (ord(char) &gt;&gt; 3)) ^ 111) &amp; 255 if c==j: print(chr(i))]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[easycreakme]]></title>
    <url>%2F2018%2F11%2F10%2Feasycreakme%2F</url>
    <content type="text"><![CDATA[题目有加壳，但是因为该壳导致程序异常，作者补发未加壳的程序，逆向这个IDA载入很清楚的可以发现先后与a,5y,R3versing,E进行比较若都符合 输出congratulation!!那么我们的flag就是Ea5yR3versing最后记得加上ctf{}再提交 转自CSDN，原链接]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向观察]]></title>
    <url>%2F2018%2F11%2F10%2F%E9%80%86%E5%90%91%E8%A7%82%E5%AF%9F%2F</url>
    <content type="text"><![CDATA[此题为Linux下调试首先下载下来放到Ubuntu里，chmod +x 附上执行权限，发现程序需要后挂参数运行 rev50 123456gdb -q rev50 #gdb挂载调试此程序然后disas main 显示所有的函数，发现有2个比较函数，此时断点下哪个都行然后set args 123456设置挂载参数r跑起来停在flag的地方，直接得到IDA调试shift+F12找到比较关键字双击然后F5调到伪代码的地方，箭头所指的地方摁R键转换转换之后\r的意思就是反转，剩下的就你懂得 转自实验吧，原文作者实验吧ID pewjs]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1000]]></title>
    <url>%2F2018%2F11%2F10%2F1000%2F</url>
    <content type="text"><![CDATA[首先，打开界面，提示：密码为纯数字，1000有特殊含义。于是输入8，按确认键。 收到安全软件的提示：有程序修改浏览器收藏夹去收藏夹位置看看，果然有一个flag.txt，打开看起来好像是key然后直接粘贴到网站答案，提示不对。恩想了想，这个key是good this is key，少了一个y，于是尝试在后面添加“y”或者“Y”，成功！ 所以最后的答案就是CTF{G00dTh1sIskeY} 转自实验吧，原文作者实验吧ID Augus]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100w]]></title>
    <url>%2F2018%2F11%2F10%2F100w%2F</url>
    <content type="text"><![CDATA[该CrackMe要求输入合适的六位数字，正确的话会输出flag暴力尝试密码就用按键精灵好了……题目名称是100w，里边的提示是6位数字，那么就是有100w种可能喽~（000000-999999），用按键精灵的话实测把全部的延时去掉（是否会有未知问题暂时不清楚，比如电脑处理能力跟不上等……我的I7-4702MQ没出现这个问题……）每分钟大约能尝试230个密码左右，100w次尝试的数学期望大约3天左右……所以采用了多个电脑同时进行的方式……这样可以缩短数学期望值……下面给出按键精灵的代码（为了节约时间，本人将程序缩减了一些，这段程序是测试73000-83000的密码，最终密码就在这里边，直接给出最终的密码就没意思了，还是体验下这个过程吧，注释尽可能的写全了，不懂得可以评论咨询~）：尝试到正确的密码，会弹出正确窗口，脚本检测到这个窗口也就会停止测试 转自实验吧，原文作者实验吧ID hanyuhang]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷路]]></title>
    <url>%2F2018%2F11%2F10%2F%E8%BF%B7%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[拿到程序后，首先运行一下，看看情况：载入IDA，查看一下字符串，看到了Y0u win等字样，结合ollydbg动态分析之后，明白了程序的基本流程。首先将获取的输入经atol()函数转为数字，并与92381221h做比较，之后对输入做md5并将结果与4850B7446BBB20AAD140E7B0A964A57D进行比较，一致则success。而经查询4850B7446BBB20AAD140E7B0A964A57D对应的明文是sakjflks。这样叫我如何是好？既要等于92381221h又要是sakjflsk，除此之外，sakjflsk经该程序md5之后有些位置为大写字母，有些为小写，要满足这些实在是不现实。之后想对按钮下一个消息断点，从头看看是否忽略了什么东西。结果看到了这个，原来里面有两个”输入(Input)”的button，od里ctrl+g搜索ShowWindow下断。这里可以看到有一个按钮被hide了，把它的值00000000改成00000001即可。这才是它正常的面貌。右边那个应该是在逗我。在GetWindowTextA处下断，od里逐步跟发现这里是个很关键的地方，一言不合就跳到失败的地方去了，IDA里f5看看里面是什么可以看到这是在判断输入是否满足基本格式OOCTF{里面有32位}。输入需要满足这种格式。满足这些条件后，程序运行到这里，调用函数00401860，且传入的参数正是{}里面的32位字符串。经该函数处理后，得到另外一串字符串，并调用函数00402d06进行判断是否一致。现在思路很清晰了，输入的字符串首先由函数00401740进行格式判断，满足格式后，再由函数00401860对{}中的32位数据进行处理，处理结果由函数00402d06判断是否等于b5h760h64R867618bBwB48BrW92H4w5r。现在的关键就是函数00401860的过程，IDA里面看该函数的代码：该函数对于字符串中的数字不做处理，字母转化成字母表中对应的0-25之间的数值，并由进行处理，之后将得到的v9再转化成相应的字母，其中v5,v6的值用od跟的过程中可以看到，v6等于28，v5在之前由sub_41458e进行过处理，为3或5。加密算法清楚了，解密即可，至于v5的值,3和5都试一下，5可以得到正确答案。 转自实验吧，原文作者实验吧ID c0smic]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密算法]]></title>
    <url>%2F2018%2F11%2F10%2F%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[我们截获了敌方传输的密文的十六进制表示如下 93 5c 96 ab e8 f0 14 cf 32 48 0f 3a 59 f4 ad 7f b3 ce 8a 4f b8 7e 77 20 并通过谍报手段得到了对方的加密程序以及密钥为：12345678我们现在希望知道对方的明文是什么 这是单纯的DES加密算法，DES是对称加密，且不管有没有变形，对称性不会改变。此WP就是要兵不血刃，利用DES的对称性及加密与解密区别仅在于取扩展密钥的顺序不同，让程序自己输出flag。至于DES加密算法就不打算分析了。关闭动态基址：修改程序偏移0x166处的”40”为”00”，保存。OD载入程序。4026d9下断，F9运行，随便输入24个字符，断下后，当前栈上存放的是输入字符存放地址，修改输入的字符为题目提供的密文。修改00402610处的 mov esi,DES.0042EF20 为 mov esi,DES.0042f1f0修改00402627处的 add esi,0x30 为 sub esi,0x30修改0040262E 处的 cmp esi,DES.0042F220 为 cmp esi,DES.0042EF20修改00402634处的 jl short DES.00402617 为jge short DES.00402617F9运行，输入密钥12345678程序输出： 43 54 46 7b 54 68 31 73 5f 31 73 5f 46 49 40 67 7d 20 20 20 20 20 20 20 都是16进制值，转ASCII字符串即可 转自实验吧，原文作者实验吧ID poyoten]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Just Click]]></title>
    <url>%2F2018%2F11%2F10%2FJust-Click%2F</url>
    <content type="text"><![CDATA[PEID检测为C#程序上.NET Reflector,在主函数里发现有个check函数跟进去查看check函数左右注意弹窗success之后的动作，将sp1234的字符串拼接输出，去资源文件找sp把sp1234的值按顺序拼接就是flag，题目有点坑，首字母要大写，to转To，题目问题]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分道扬镳]]></title>
    <url>%2F2018%2F11%2F10%2F%E5%88%86%E9%81%93%E6%89%AC%E9%95%B3%2F</url>
    <content type="text"><![CDATA[这题很好玩。首先是PEID查壳，32位的无壳程序，拖入IDA，找到关键代码 char *sub_401020() { char *result; // eax@19 char v1; // [sp+Ch] [bp-110h]@1 char v2; // [sp+4Ch] [bp-D0h]@11 char *v3; // [sp+50h] [bp-CCh]@1 char v4; // [sp+54h] [bp-C8h]@1 char v5; // [sp+5Dh] [bp-BFh]@1 char v6; // [sp+94h] [bp-88h]@15 char v7; // [sp+98h] [bp-84h]@1 char v8; // [sp+99h] [bp-83h]@1 __int16 v9; // [sp+10Dh] [bp-Fh]@1 char v10; // [sp+10Fh] [bp-Dh]@1 char v11; // [sp+110h] [bp-Ch]@11 char v12; // [sp+114h] [bp-8h]@5 int v13; // [sp+118h] [bp-4h]@4 memset(&amp;v1, 0xCCu, 0x110u); v7 = 0; memset(&amp;v8, 0, 0x74u); v9 = 0; v10 = 0; qmemcpy(&amp;v4, &quot;********* * ** * ** ** * ** ** * #* ** **** ** *********&quot;, 0x41u); v3 = &amp;v5; printf(&quot;Please input your key:\n&quot;); gets(&amp;v7); if ( strlen(&amp;v7) != 22 ) // 长度为22 { printf(&quot;Sorry you are wrong!\n&quot;); system(&quot;pause&quot;); exit(1); } v13 = 0; do { v12 = *(&amp;v7 + v13); if ( v12 != 107 &amp;&amp; v12 != 106 &amp;&amp; v12 != 104 &amp;&amp; v12 != 108 ) // 只能输入这几个数 { printf(&quot;Sorry you are wrong!\n&quot;); system(&quot;pause&quot;); exit(2); } v11 = *(&amp;v7 + v13); v2 = v11; // 不同的输入对应不同的走法 if ( v11 == 104 ) { if ( --v3 &lt; &amp;v4 || v3 &gt; &amp;v6 || (result = (char *)*v3, result == (char *)42) ) { printf(&quot;Sorry you are wrong!\n&quot;); system(&quot;pause&quot;); exit(3); } if ( *v3 == 35 ) { LABEL_41: printf(&quot;Good!\n&quot;); system(&quot;pause&quot;); exit(0); } } else if ( v2 == 106 ) { v3 += 8; if ( v3 &lt; &amp;v4 || v3 &gt; &amp;v6 || *v3 == 42 ) { printf(&quot;Sorry you are wrong!\n&quot;); system(&quot;pause&quot;); exit(3); } result = (char *)*v3; if ( result == (char *)35 ) goto LABEL_41; } else if ( v2 == 107 ) { v3 -= 8; if ( v3 &lt; &amp;v4 || v3 &gt; &amp;v6 || *v3 == 42 ) { printf(&quot;Sorry you are wrong!\n&quot;); system(&quot;pause&quot;); exit(3); } result = v3; if ( *v3 == 35 ) goto LABEL_41; } else { if ( ++v3 &lt; &amp;v4 || v3 &gt; &amp;v6 || *v3 == 42 ) { printf(&quot;Sorry you are wrong!\n&quot;); system(&quot;pause&quot;); exit(4); } result = v3; if ( *v3 == 35 ) goto LABEL_41; } ++v13; } while ( v13 &lt; 25 ); return result; } 上面的代码首先给出了一段字符********* * ** * ** ** * ** ** * #* ** **** ** *********，现在要求输入一段字符串，只能包含四种字符，分别是h,j,k,l，长度是22位。这四种字符都对应一种走法。现在我们的起始地址在第十位，要求通过这几种走法，不可以经过*，走到#，我们要找的就是这样一种走法。可以通过深度优先搜索解决(DFS)，遍历所有可能走法，最后跳出一种满足条件的走法，给出代码: #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;string&gt; #include &lt;string.h&gt; using namespace std; char num[25]; int dfsmap[70]={1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1}; void dfs(int x,int sumn) { int i,j,k; if(sumn==22) { if(x==36) // 满足条件就输出 { for(i=0;i&lt;=21;i++) { cout&lt;&lt;num[i]; } cout&lt;&lt;endl; } return; } // 四种走法 if(x-1&gt;=0&amp;&amp;dfsmap[x-1]!=1) { num[sumn]=&#39;h&#39;; dfs(x-1,sumn+1); num[sumn]=0; } if(x+8&lt;=63&amp;&amp;dfsmap[x+8]!=1) { num[sumn]=&#39;j&#39;; dfs(x+8,sumn+1); num[sumn]=0; } if(x-8&gt;=0&amp;&amp;dfsmap[x-8]!=1) { num[sumn]=&#39;k&#39;; dfs(x-8,sumn+1); num[sumn]=0; } if(x+1&lt;=63&amp;&amp;dfsmap[x+1]!=1) { num[sumn]=&#39;l&#39;; dfs(x+1,sumn+1); num[sumn]=0; } return; } int main() { dfs(9,0); return 0; } 结果是******kkkhhhjjjl 转自实验吧，原文作者实验吧ID chih1e]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10000000]]></title>
    <url>%2F2018%2F11%2F10%2F10000000%2F</url>
    <content type="text"><![CDATA[先在IDA中看看程序逻辑，找到关键代码在OD中找到需要比较的字符串v4给出exp： v4 = [0xE6,0xEC,0xE1,0xE7,0xBA,0xF4,0xE5,0xF3,0xF4,0xF4,0xE5,0xF3,0xF4] v14 = [] for i in range(len(v4)): v14.append(v4[i]-0x80) # 或运算的逆运算是减法 flag = &#39;&#39; for i in v14: flag += chr(i) print flag]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[smali文件分析]]></title>
    <url>%2F2018%2F11%2F10%2Fsmali%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[题目是smali文件问下，给的却是个apk，这不就给我偷懒的机会了嘛直接转jar看源码更方便只有一个foo函数，根据传参，计算foo的返回值，结束]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流水线]]></title>
    <url>%2F2018%2F11%2F10%2F%E6%B5%81%E6%B0%B4%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[这个程序运行时会闪退，没有任何输入输出，因为出题人根本就没写输入输出语句，因此非进行逆向工程不可。此时，或许我们首先应该去搜索一下，什么叫作Feistel结构？不难搜到这张图：左侧由上而下是加密算法，右侧由上而下是解密算法，K代表密钥，F代表一个函数，圈中十字那个符号代表异或（XOR）运算，在C语言中对应的运算符是^。可以看出，Feistel结构的加密算法首先需要一组密钥（K0～Kn），一个函数（F）。它将输入的原文分为两个部分，暂且称为L和R，不断重复以下过程： 将R和K进行F运算，得到的结果再和L做异或运算，得到的结果成为下一轮的R； R直接成为下一轮的L。 例外：最后一轮后不交换L和R。解密过程完全相同，只不过把K全都反过来了，先用Kn，最后用K0。于是，确定算法的K和F就是我们接下来的目标。打开IDA，如图导出所有源码这里插一句：即使源代码只有main一个函数，编译时编译器也会加上很多东西，这导致反编译出的代码中有一大堆搞不懂在干什么的函数。不过不用管它们，我们快速的寻找可能是加密算法的程序段——加密算法含有异或运算，所以直接在代码中搜索^符号应该就能找到它。可以注意到这一段程序最为可疑，它不调用别的奇奇怪怪的函数，还包含一些不知道代表什么的常数，并且大量使用异或运算（多到我不换行就没法把那一行放在这个页面中了），这很像加密过程： int sub_401500() { signed int v0; // ebx@1 int v1; // esi@2 int v2; // ecx@2 signed int v4; // [sp+14h] [bp-18h]@1 int v5; // [sp+18h] [bp-14h]@0 int v6; // [sp+1Ch] [bp-10h]@0 sub_401F10(); v4 = 0; v0 = 225052; while ( v4 &lt;= 15 ) { v1 = v6; v2 = ((v0 + v6) &lt;&lt; 8) ^ v6 ^ 2 * v0 ^ (v6 &lt;&lt; (v0 + 8)) ^ v0 * (v6 + 4) ^ (25998 * v6 + 174 * v0) ^ v5; if ( v4 % 3 == 1 ) v0 = __ROL4__(v0, 1); else v0 = __ROL4__(v0, 2); v6 = v2; v5 = v1; ++v4; } return 0; } 中间调用的sub_401F10经过检查后可以发现并没什么值得注意的，就忽略吧。我们接下来的任务是搞清楚v0、v1、v2、v4、v5、v6都是存储什么的。很容易看出v4是从0到15的循环变量，我们命名为i。观察v2=…那一段，可以发现是v0和v6先进行了复杂运算，结果再与v5进行异或运算，结果存入v2，最终又存入v6。因此有理由推测v5是L，v0是K，v6是R，v2是一个临时存储R的新值的变量，那一大段运算是F。另外，v1是一个临时存储L的旧值的变量。等等，不是说K有很多个，应该是16轮计算中K各不相同吗？怎么成了v0呢？请看，在循环的后面，有一个动作是v0 = ROL4(v0, 1);或v0 = ROL4(v0, 2);。上网搜索可知，ROL4代表“向左循环移位”，这就是在旧的v0的基础上产生出一个新的v0给下一轮用啊！而且，v4是否为3的整数倍，决定了新的v0是怎么产生的。我们可以使用下面这段程序得到全部16轮使用的K： void getKs(int K[16]) { int i, v0 = 225052; for(i = 0; i &lt; 16; i++) { K[i] = v0; if ( i % 3 == 1 ) v0 = __ROL4__(v0, 1); else v0 = __ROL4__(v0, 2); printf(&quot;%d&quot;, v0); } } 其中的ROL4的算法如下： int __ROL4__(unsigned int v, int n) { return (v &lt;&lt; n) | (v &gt;&gt; (32 - n)); } 而F也很容易写出： int F(int R, int K) { return ((K + R) &lt;&lt; 8) ^ R ^ 2 * K ^ (R &lt;&lt; (K + 8)) ^ K * (R + 4) ^ (25998 * R + 174 * K); } 综上所述，对变量名进行修改，对程序进行简化后，加密过程其实就是： void Encrypt() { int K[16], t, i, L, R; getKs(K); for(i = 0; i &lt; 16; i++) { t = R; R = F(R, K[i]) ^ L; L = t; } } 把K反过来使用，得解密过程: void Decrypt() { int K[16], t, i, L, R; getKs(K); for(i = 0; i &lt; 16; i++) { t = R; R = F(R, K[15 - i]) ^ L; L = t; } } 为L和R赋初始值2和1（顺序是试出来的，以上程序都没有考虑结束时是否交换一次L和R的问题，所以可能要用不同的顺序多试试），运行加密过程并打印结束时的L和R，可以确认我们的程序是正确的。为L和R分别赋初始值860103762和1574863430，运行解密过程，便得到答案。 另一种解法：暴力破解……虽然极不推荐，但有人居然成功了，出于神人共欣赏的考虑，将他的解法也收录于此…… 首先，为什么说不推荐呢？因为a和b都是int型整数，合起来可能的解有18446744073709551616种，若检验一个解的时间是1纳秒（事实上一般CPU1纳秒只能执行几条指令），那么需要585年才能穷举完所有解。但是！在有人劝说别人放弃暴力破解的尝试时，他无意间说“答案都是六位数”，暴露了这道题答案数字小的缺陷。如果已知a和b都是六位正整数，解就只有810000000000种了，每个解花10纳秒，只需要2.25小时就能穷举完。这使得@Core i5 2nd Generation 同学用一上午暴力破解跑出了答案！（注：他当然不能不断尝试在网站上提交，那样太慢了。他是写了个main，不断调用逆向工程得到的那个加密函数，在本地进行破解的。并且他将解分为了7部分，同时开7个程序各占一个线程进行尝试） 转自hebin.me 原文链接]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lol]]></title>
    <url>%2F2018%2F11%2F10%2Flol%2F</url>
    <content type="text"><![CDATA[Point: so file Ollvm encode.read the fucking while code. nothing to say. #include &quot;stdafx.h&quot; #include &lt;conio.h&gt; int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) { // TODO: Place code here. unsigned char data[24] = { 0x4E, 0x5A, 0x40, 0x72, 0x6F, 0x6C, 0x36, 0x38, 0x68, 0x56, 0x69, 0x49, 0x73, 0x38, 0x71, 0x6C, 0x58, 0x7E, 0x37, 0x7B, 0x36, 0x6D, 0x26, 0x74 }; unsigned char v24[25] = {0}; for (int i = 0; i &lt; sizeof(data); i++) { static int a = 0; for (int v4 = 0; v4 &lt; 256; v4++) { v24[i] = (unsigned char)v4; unsigned char v7 = 0; if (a % 2 == 0) v7 = (v24[i] &amp; 0x26 | ~v24[i] &amp; 0xD9) ^ 0xDE; else v7 = (v24[i] &amp; 0xF6) | ~v24[i] &amp; 9; if (v7 == data[i]) break; } a++; } getch(); return 0; } 转自实验吧，原文作者实验吧ID Nius]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输出没有输出的内容]]></title>
    <url>%2F2018%2F11%2F10%2F%E8%BE%93%E5%87%BA%E6%B2%A1%E6%9C%89%E8%BE%93%E5%87%BA%E7%9A%84%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[上来先看了下壳，没有。直接上IDA，发现原来是MAC系统下的东西，我没有MAC，看来要在IDA下一条路走到黑了。进了IDA，如图：函数不多，松了口气。直接进start。似乎程序总体结构一览无余。先输入KEY，然后由两个sub进行KEY的变换，所得结果与aN进行比较。进KEY变换的两个sub看了下，第二个sub比较复杂。第二个sub我不上图了，简单说下，主要是多层循环控制结构，主要进行移位、或、与、取反、异或操作，没整明白。但仔细看下，发现对KEY的变换操作特别少，而且没有对aN的操作。aN在程序中初始状态如图。所以aN不是flag，这也正符合提示：没有输出的内容。接着往下看，下面还有个函数sub_100001530，输入参数是KEY经过第一个字串处理函数变换后的值。先对输入参数分别与两个字串进行变换，然后进入一个循环，访问网络并对字串进行处理。折腾很久，没有折腾出结果。后来网上找到一篇WP（http://www.secpulse.com/archives/39058.html），一切就清楚了，写这篇WP就是想把网上WP略过的东西说说。毕竟我是小菜，flag不是目的，学习才是目的。如果把sub_100001530的输入参数记作a,如网上的WP如说，在sub_100001480中用a的前6位与目标字串进行异或生成一个url，url的开头肯定是http://或者https://。这样就可以反推出a的前6位，并再得出url。而且还可以用a算出另一个字串的变换结果。直接上代码，两种可能性都算，一看便知真假。 # -*- coding:utf-8 -*- # code by poyoten def main(): t1 = r&#39;http:/&#39; t2 = r&#39;https:&#39; #b为unk_1000020E0 b = [0x3c,0x44,0x19,0x11,0x7,0x55,0x7B,0x1F,0x0E,0x15,0x12,0x1B,0x3D,0x5D,\ 0x8,0x4F,0x1B,0x1D,0x33,0x1F,0x8,0x17,0x11,0x1,0x20,0x1F] #c为unk_100002100 c = [0xF1,0x31,0x78,0x98,0xC0,0x62,0x50,0x7A,0xDA,0x62,0x70,0x9D,0xFE,0x2D,\ 0x6E,0xC3,0xEE,0x7A,0x51,0xA,0xC8,0x74,0x74,0xE,0xC2,0x31,0x6D,0xBD,0xFB,\ 0x6A,0x57,0x94,0xEC,0x6E,0x7C,0x77,0xF1,0x37,0x6F,0x95,0x3,0x56,0x57,0xD8,\ 0xE0,0x6A,0x70,0x5D,0xCE,0x33,0x6F,0x61,0xD1,0x64,0x55,0x75,0xC7,0x66,0x74,\ 0xC0,0xD5,0x3B,0x6E,0x19,0xE0,0x62,0x5C,0x18,0xDA,0x44,0x75,0x9A] a1 = &#39;&#39; a2 = &#39;&#39; for i in range(6): a1 += chr(ord(t1[i]) ^ b[i]) a2 += chr(ord(t2[i]) ^ b[i]) print a1,&#39;\t&#39;,a2 b1 = &#39;&#39; b2 = &#39;&#39; for i in range(len(b)): b1 += chr((b[i]^ord(a1[i%len(a1)]))) b2 += chr((b[i]^ord(a2[i%len(a2)]))) c1 = [] c2 = [] for i in range(len(c)): c1.append(c[i]^ord(a1[i%len(a1)])) c2.append(c[i]^ord(a2[i%len(a2)])) print b1,&#39;\n&#39;,b2,&#39;\n&#39;,c1,&#39;\n&#39;,c2 if __name__ == &#39;__main__&#39;: main() print &#39;done&#39; pass 得出一个网址和一组数，代入sub_10000133进行运算，最终能得出flag。既然内容没有输出，我也没有MAC，那我们输出内容吧。代码如下，尽量保持了伪代码的原样。 // poppy.cpp : Defines the entry point for the console application. //code by poyoten #include &quot;stdafx.h&quot; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;memory.h&gt; #include &lt;stdlib.h&gt; #include &lt;curl/curl.h&gt; #define WIN32_LEAN_AND_MEAN #include &lt;windows.h&gt; size_t sub_1000011C0(void* a1, size_t a2, size_t a3, void* a4) { __int64 v4; // ST18_8@1 v4 = a3; //memset(data, 0LL, 0x1000000LL); int size = strlen((char*)a4); int len = size_t(a3*a2); if (size == 0) strcpy_s((char*)a4, len+1, (char*)a1); else strcat_s((char*)a4, 0x1000000uLL, (char*)a1); return size_t(a3*a2); } _int64 __fastcall sub_100001210(char* a1, char* a2) { CURL *curl; // ST38_8@1 CURLcode res; //FILE* fp; //if ((fp = fopen(&quot;1.htm&quot;, &quot;w&quot;)) == NULL) // return false; //__memset_chk(a2, 0LL, 0x100000LL, -1LL); curl_global_init(3LL); curl = curl_easy_init(); curl_easy_setopt(curl, CURLOPT_URL, a1); curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30LL); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, sub_1000011C0); //curl_easy_setopt(curl, CURLOPT_FILE, (FILE*)a2); curl_easy_setopt(curl, CURLOPT_WRITEDATA, a2); curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0LL); curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0LL); res = curl_easy_perform(curl); curl_easy_cleanup(curl); curl_global_cleanup(); return 0LL; } __int64 __fastcall sub_100001740(const char *a1, int a2, char *a3, int a4, int a5) { signed int v5; // eax@42 signed int v6; // eax@45 signed int v7; // eax@48 signed int v8; // eax@53 signed int v9; // eax@57 signed int v10; // eax@62 signed int v11; // eax@65 bool v13; // [sp+7Bh] [bp-45h]@0 signed int v14; // [sp+7Ch] [bp-44h]@1 char *v15; // [sp+80h] [bp-40h]@0 char *v16; // [sp+88h] [bp-38h]@0 int v17; // [sp+94h] [bp-2Ch]@0 int v18; // [sp+98h] [bp-28h]@1 int v19; // [sp+9Ch] [bp-24h]@1 char *v20; // [sp+A0h] [bp-20h]@1 signed int v21; // [sp+B8h] [bp-8h]@0 int v22; // [sp+BCh] [bp-4h]@1 v20 = a3; v19 = a4; v18 = a5; v22 = a5; v14 = 687849597; do { while (v14 &gt; -721349906) { if (v14 &gt; -251959739) { if (v14 &gt; 1643955) { if (v14 &gt; 2139374635) { if (v14 == 2139374636) { v11 = 1996424361; if (v17 &lt; v18) v11 = -251959738; v14 = v11; } } else if (v14 &gt; 111058115) { if (v14 &gt; 319798562) { if (v14 &gt; 497514003) { if (v14 &gt; 687849596) { if (v14 &gt; 1056727273) { if (v14 &gt; 1629186829) { if (v14 &gt; 1841852057) { if (v14 &gt; 1996424360) { if (v14 == 1996424361) { v21 = (DWORD)v15 - (DWORD)v20; v14 = -2127602345; } } else { switch (v14) { case 1841852058: v6 = 111058116; if (a2 &lt;= 0) v6 = 319798563; v14 = v6; break; case 1892047314: v8 = -721349905; if (v17 &lt; v18) v8 = 497514004; v14 = v8; v13 = 0; break; case 1914277125: v10 = 2139374636; if (!v15) v10 = -251959738; v14 = v10; break; } } } else if (v14 == 1629186830) { v16 += (signed int)v15 - (signed int)v16 + 1; v14 = 1643956; } } else if (v14 == 1056727274) { v17 = 0; v16 = v20; v14 = 1892047314; } } else if (v14 == 687849597) { v5 = 1841852058; if (v22 &lt;= 0) v5 = 319798563; v14 = v5; } } else if (v14 == 497514004) { v15 = strstr(v16, a1); v14 = -721349905; v13 = v15 != 0LL; } } else if (v14 == 319798563) { v21 = -1; v14 = -2127602345; } } else if (v14 == 111058116) { v7 = 1056727274; if (v19 &lt;= 0) v7 = 319798563; v14 = v7; } } else if (v14 == 1643956) { ++v17; v14 = 1892047314; } } else if (v14 == -251959738) { v21 = -1; v14 = -2127602345; } } else if (v14 == -721349905) { v9 = 1914277125; if (v13) v9 = 1629186830; v14 = v9; } } } while (v14 != -2127602345); return (unsigned int)v21; } __int64 __fastcall sub_100001330(char* a1, unsigned int a2, int a3) { int v3; // ST70_4@1 char* v4; // ST60_8@1 int v5; // eax@1 int v6; // eax@1 int v7; // ST5C_4@1 const char *v8; // ST10_8@1 int v9; // eax@1 char v10; // ST4B_1@1 v3 = a3; v4 = (char *)malloc(0x1000000uLL); memset(v4, 0LL, 0x1000000LL); //v4 = data; sub_100001210(a1, v4); v5 = strlen(v4); v6 = sub_100001740(&quot;&lt;td&gt;&quot;, 4, v4, v5, a2); v7 = v6; v8 = &amp;v4[v6 + 4]; v9 = strlen(v8); v10 = v4[(signed int)(v3 + (unsigned __int64)sub_100001740(&quot;\&quot;&gt;&quot;, 2, (char *)v8, v9, 1) + v7 + 4 + 2)]; free(v4); return (unsigned int)v10; } int _tmain(int argc, _TCHAR* argv[]) { __int64 v1; // rcx@3 char v2; // al@3 __int64 v4; // [sp+0h] [bp-1F0h]@0 char *i; // [sp+70h] [bp-180h]@1 char *v6; // [sp+80h] [bp-170h]@3 char *v7; // [sp+C0h] [bp-130h]@1 char *v8; // [sp+1C0h] [bp-30h]@1 __int64 v9; // [sp+1E8h] [bp-8h]@1 char url[] = &quot;https://ctftime.org/event/&quot;; char index[] = {165, 1, 21, 249, 180, 13, 4, 74, 183, 3, 4, 242, 170, 29, 3, 162, 154, 21, 5, 58, 165, 21, 0, 97, 150, 1, 0, 220, 143, 5, 3, 164, 129, 15, 8, 24, 165, 7, 2, 244, 119, 57, 3, 232, 141, 11, 4, 50, 154, 3, 2, 0, 165, 11, 1, 69, 170, 7, 0, 175, 129, 11, 3, 120, 148, 13, 8, 40, 183, 37, 1, 245,&#39;\0&#39; }; //memset(&amp;v8, 0, 0x20uLL); //memset(&amp;v7, 0, 0x100uLL); v7 = index; v8 = url; //strcpy(&amp;v8, url); //strcpy(&amp;v7, index); for (i = v7; *i; i += 4) { //memset(&amp;v6, 0, 0x40uLL); v6 = (char *) malloc(0x100ULL); WORD(v4) = (unsigned __int8) *i; _snprintf(v6, 0x40uLL, &quot;%s%d&quot;, v8, v4); v1 = (unsigned __int8)*i; v2 = sub_100001330(v6, (unsigned __int8)i[1], (unsigned __int8)i[2]); printf(&quot;%c&quot;, v2); } return 0; } 得出没有输出的内容。不过还有个格式，本题未说明白，原题说了。我不知道aN输出的是什么，也不想弄了。程序中是带有ISG字串的。不要问我怎么知道的。 转自实验吧，原文作者实验吧ID poyoten]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tlc]]></title>
    <url>%2F2018%2F11%2F10%2Ftlc%2F</url>
    <content type="text"><![CDATA[先用ida64打开tlc buf = 0LL; v10 = 0; memset(&amp;v8, 0, 0x400uLL); memset(&amp;s, 0, 0x400uLL); printf(&quot;Please input key: &quot;, a2, &amp;s); fflush(stdout); read(0, &amp;buf, 0xCuLL); sub_401241((const char *)&amp;buf); 看到这个函数是对输入字符串进行rot13操作（核心语句：a1[v3] = (a1[v3] + 13) % (v4 + 26);）sub_400EC7((int64)&amp;buf, (int64)&amp;s, 0xCuLL);这个函数是进行base64解码操作（因为有base64的三段式位移 v3 = 4 * (unsigned __int64)sub_400AAD(*(_BYTE *)(a1 + i)); *(_BYTE *)(a2 + v14) = v3 | ((signed int)(sub_400AAD(*(_BYTE *)(i + 1 + a1)) &amp; 0x30) &gt;&gt; 4); v4 = 16 * (unsigned __int64)sub_400AAD(*(_BYTE *)(i + 1 + a1)); *(_BYTE *)(v14 + 1 + a2) = v4 | ((unsigned __int8)sub_400AAD(*(_BYTE *)(i + 2 + a1)) &gt;&gt; 2); v5 = (unsigned __int8)sub_400AAD(*(_BYTE *)(i + 2 + a1)) &lt;&lt; 6; *(_BYTE *)(v14 + 2 + a2) = v5 | (unsigned __int64)sub_400AAD(*(_BYTE *)(i + 3 + a1)); ） v3 = strlen(&amp;s); sub_4006B6((__int64)&amp;s, v3); 这里是一个判断函数，如果不满足条件则直接exit v4 = 10 * v4 + *(_BYTE *)(i + a1) - 48; if ( v4 % (i + 1) ) exit(1); 从形式上看，输入很可能是数字，因为每个输入的ascii码与“0”的相减，然后按位检查是否能够整除 v11 = malloc(0x108uLL); v4 = strlen(&amp;s); sub_400877((__int64)v11, (__int64)&amp;s, v4);# 这里就是各种操作，只要能过判断函数，都能解得一个结果，就是看是否有意义而已 v5 = strlen(::s); sub_400A1B((__int64)v11, (__int64)&amp;v8, (__int64)::s, v5); printf(&quot;Text is: %s\n&quot;, &amp;v8); return 0LL; 所以综上：首先输入然后rot13,然后base64解码,然后做了一个判断(高n位能被n整除),最后用输入作为密钥解密一段数据,得到flag。 转自实验吧，原文作者实验吧ID canic]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSCTF Reverse 500]]></title>
    <url>%2F2018%2F11%2F10%2FNSCTF-Reverse-500%2F</url>
    <content type="text"><![CDATA[题目给的提示是pyc的反编译于是去找pyc反编译的工具 ，使用Easy Python Decompiler反编译，得到报错 Syntax error at or near `NOP&#39; token at offset 0 # decompiled 0 files: 0 okay, 1 failed, 0 verify failed ParserError: --- This code section failed: --- NOP &#39;&#39; LOAD_CONST &quot;M,\x1d-\x18}E&#39;\x1ezN~\x1b*\x19+\x12%\x1d-&quot; LOAD_CONST &quot;M,\x1d-\x18}E&#39;\x1ezN~\x1b*\x19+\x12%\x1d-&quot; NOP &#39;&#39; LOAD_CONST &quot;M,\x1d-\x18}E&#39;\x1ezN~\x1b*\x19+\x12%\x1d-&quot; LOAD_CONST &#39;I\x7fM(I{I\x7fJ.\x16wWcRj\x0e6\x0fn&#39; 参考 Python字节码指令集 有 0x09(009): NOP根据 报错 将 09 64 改成 01 64 但得到的代码不全 # File: R (Python 2.7) &quot;M,\x1d-\x18}E&#39;\x1ezN~\x1b*\x19+\x12%\x1d-&quot; data = &quot;M,\x1d-\x18}E&#39;\x1ezN~\x1b*\x19+\x12%\x1d-&quot; + &#39;I\x7fM(I{I\x7fJ.\x16wWcRj\xe6\xfn&#39; + &#39;Zo\nn\xfk\t1R7\x3g\x67\x0eUb\x43&#39; + &#39;\x14\x71Rr\x14x\x19~D?q&quot;a5s,A%&#39; + &quot;\x10&#39;\x11uLyA%\x1d|DrFv\x12t\x11#B&amp;&quot; + &#39;GsKzK*O)\x1c%GuC&gt;\x1e\x7f\x1b+\x19*&#39; + &#39;\x1e&amp;\x14-\x1f/\x1axAqBq@yO-LtE}&#39; + &#39;\x1b,MuBp\x12&#39; import os import sys import struct import cStringIO import string import dis import marshal import types import random count = 0 def reverse(string): return string[::-1] data_list = list(reverse(data)[1:]) def decrpyt(c, key2): global count data_list[count] = c ^ key2 count += 1 def GetFlag1(): key = struct.unpack(&#39;B&#39;, data[len(data) - 8])[0] for c in data_list: if count == 0: decrpyt(struct.unpack(&#39;B&#39;, c)[0], key) continue key = struct.unpack(&#39;B&#39;, data[len(data) - 3])[0] decrpyt(struct.unpack(&#39;B&#39;, c)[0], key) for c in data_list[::-1]: print chr(c), def GetFlag2(): key = struct.unpack(&#39;B&#39;, data[len(data) - 11])[0] for c in data_list: if count == 0: decrpyt(struct.unpack(&#39;B&#39;, c)[0], key) continue key = struct.unpack(&#39;B&#39;, data[len(data) - 4 - count])[0] decrpyt(struct.unpack(&#39;B&#39;, c)[0], key) for c in data_list[::-1]: print chr(c), def GetFlag3(): key = struct.unpack(&#39;B&#39;, data[len(data) - 5])[0] for c in data_list: if count == 0: decrpyt(struct.unpack(&#39;B&#39;, c)[0], key) continue key = struct.unpack(&#39;B&#39;, data[len(data) - 2 - count])[0] decrpyt(struct.unpack(&#39;B&#39;, c)[0], key) for c in data_list[::-1]: print chr(c), def GetFlag4(): global count key = struct.unpack(&#39;B&#39;, data[len(data) - 1])[0] for c in data_list: if count == 0: decrpyt(struct.unpack(&#39;B&#39;, c)[0], key) continue key = struct.unpack(&#39;B&#39;, data[len(data) - 1 - count])[0] decrpyt(struct.unpack(&#39;B&#39;, c)[0], key) count = 0 for c in data_list[::-1]: print chr(c), def GetFlag5(): pass # WARNING: Decompyle incomplete GetFlag1() 编写 解析data的程序 ，但到解析 第二个字符串时开始 报 ValueError: invalid \x escape 发现 Decompyle++ 在处理 例如 0f aa 这样的指令时也会变成 \xfa\xa所以手动获取 data data = &quot;4D2C1D2D187D45271E7A4E7E1B2A192B12251D2D497F4D28497B497F4A2E16775763526A0E360F6E5A6F0A6E0F6B09315237036706370065556204330134073152721478197E443F71226135732C4125102711754C7941251D7C4472467612741123422647734B7A4B2A4F291C254775433E1E7F1B2B192A1E26142D1F2F1A784171427140794F2D4C74457D1B2C4D75427012&quot;.decode(&#39;hex&#39;) 依次尝试 GetFlag在 GetFlag4 中得到 flag 转自实验吧，原文作者实验吧ID 笛声悠悠-思绪万千]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSCTF Reverse 400]]></title>
    <url>%2F2018%2F11%2F10%2FNSCTF-Reverse-400%2F</url>
    <content type="text"><![CDATA[题目给了个py打包的exe，提示py2exe这里安利一个工具pyinstaller extractor，可以将pyinstaller打包的pyexe还原回去提前出来的源码如下看到flag明文，贼激动，提交GG……跟一边buf过程，十六进制打出来和data特别像，猜测应该是根据加密算法，逆推解密，data已知，给出解密过程 data = &quot;\x1c\x7a\x16\x77\x10\x2a\x51\x1f\x4c\x0f\x5b\x1d\x42\x2f\x4b\x7e\x4a\x7a\x4a\x7b&quot; +&quot;\x49\x7f\x4a\x7f\x1e\x78\x4c\x75\x10\x28\x18\x2b\x48\x7e\x46\x23\x12\x24\x11\x72&quot; +&quot;\x4b\x2e\x1b\x7e\x4f\x2b\x12\x76\x0b&quot; data = list(data) print len(data) for x in range(0, 48): data[x] = chr(ord(data[x]) ^ ord(data[x+1])) data[48] = chr(ord(data[48]) ^ 0x0b) print &#39;&#39;.join(data)]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bin100(ebCTF 2013)]]></title>
    <url>%2F2018%2F11%2F09%2Fbin100-ebCTF-2013%2F</url>
    <content type="text"><![CDATA[用od加载之后查找字符串可以看到要求你扔出3-1-3-3-7的骰子，这再拼运气前面4次全扔中，你最后一个也不可能把一个最大就只有6的骰子扔个7出来换个想法，找到错误跳转jnz，让它不管错误还是正确都不跳转就行了，用nop填充掉然后运行5次回车后就可以输出flag了注意有基于时间的反调试，填充完保存到可执行文件，在外面命令行运行即可]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keylead（ASIS CTF 2015）]]></title>
    <url>%2F2018%2F11%2F09%2FKeylead%EF%BC%88ASIS-CTF-2015%EF%BC%89%2F</url>
    <content type="text"><![CDATA[sub_4006B6输出了flag，静态分析不方便，IDA+Remote动态调，防止输出flag时用到了期望骰子加入计算，还是要什么给什么3，1，3，3，7。还加了时间验证防作弊，改跳转。 signed __int64 __fastcall main(__int64 a1, char **a2, char **a3) { char v3; // ST1F_1@1 unsigned int v4; // eax@1 int v5; // ST18_4@1 int v6; // ST14_4@1 signed __int64 result; // rax@6 int v8; // [sp+4h] [bp-1Ch]@1 int v9; // [sp+8h] [bp-18h]@1 int v10; // [sp+Ch] [bp-14h]@1 int v11; // [sp+10h] [bp-10h]@1 puts(&quot;hi all ----------------------&quot;); puts(&quot;Welcome to dice game!&quot;); puts(&quot;You have to roll 5 dices and get 3, 1, 3, 3, 7 in order.&quot;); puts(&quot;Press enter to roll.&quot;); v3 = getchar(); v4 = time(0LL); srand(v4); v5 = time(0LL); v6 = rand() % 6 + 1; v11 = rand() % 6 + 1; v10 = rand() % 6 + 1; v9 = rand() % 6 + 1; v8 = rand() % 6 + 1; printf( &quot;You rolled %d, %d, %d, %d, %d.\n&quot;, (unsigned int)v6, (unsigned int)v11, (unsigned int)v10, (unsigned int)v9, (unsigned int)v8); if ( v6 != 3 || (time(0LL), v11 != 1) || (time(0LL), v10 != 3) || (time(0LL), v9 != 3) || (time(0LL), v8 != 7) ) { puts(&quot;You DID NOT roll as I said!&quot;); puts(&quot;Bye bye~&quot;); result = 0xFFFFFFFFLL; } else { time(0LL); puts(&quot;You rolled as I said! I&#39;ll give you the flag.&quot;); sub_4006B6(); result = 0LL; } return result; } 转自实验吧，原文作者实验吧ID czr27]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reversemeplz]]></title>
    <url>%2F2018%2F11%2F09%2Freversemeplz%2F</url>
    <content type="text"><![CDATA[求逆函数 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define LOBYTE(x) (((char*)&amp;x)[0]) char book[256] = {0,94,24,84,113,76,8,68,48,126,24,124,81,68,8,102,80,92,88,84,48,76,24,68,48,124,24,116,16,68,24,100,0,94,120,84,113,126,123,84,48,126,24,124,89,126,8,102,64,92,120,20,48,76,104,4,32,60,24,116,8,12,8,100,44,110,47,124,121,108,40,108,125,126,127,124,121,108,105,110,115,100,117,102,48,108,57,110,51,100,53,116,16,76,16,108,36,110,111,112,113,114,115,116,117,118,119,120,121,122,97,98,99,100,101,102,103,104,105,106,107,108,109,124,79,72,72,104,0,94,24,84,113,76,8,68,48,126,24,124,81,68,8,102,80,92,88,84,48,76,24,68,48,124,24,116,16,68,24,100,0,94,120,84,113,126,123,84,48,126,24,124,89,126,8,102,64,92,120,20,48,76,104,4,32,60,24,116,8,12,8,100,44,110,47,124,121,108,40,108,125,126,127,124,121,108,105,110,115,100,117,102,48,108,57,110,51,100,53,116,16,76,16,108,36,110,111,112,113,114,115,116,117,118,119,120,121,122,97,98,99,100,101,102,103,104,105,106,107,108,109,124,79,72,72,104}; unsigned char unk_8048980[60]={255,255,255,255,17,0,0,0,245,255,255,255,3,0,0,0,248,255,255,255,5,0,0,0,14,0,0,0,253,255,255,255,1,0,0,0,6,0,0,0,245,255,255,255,6,0,0,0,248,255,255,255,246,255,255,255,0,0,0,0}; bool __cdecl sub_8048801(char *flag) { int v1; // edi@1 int v2; // esi@1 char v3; // al@6 int cnt; // eax@10 char baseVector[100]={0}; char v7=(char)(baseVector+3); // [sp+3h] [bp-59h]@13 char v8=(char)(baseVector+4); // [sp+4h] [bp-58h]@6 char v9=(char)(baseVector+5); // [sp+5h] [bp-57h]@16 int* v10=(int*)((char*)baseVector+16); // [sp+10h] [bp-4Ch]@13 char v11=(char)(baseVector+20); // [sp+14h] [bp-48h]@1 memcpy(&amp;v11, &amp;unk_8048980, 0x3Cu); v1 = 0; v2 = 0; *flag = 111; do { if ( flag[v2] &lt;= 96 ) flag[v2] = 0; if ( flag[v2] &gt; 122 ) flag[v2] = 24; v3 = book[flag[v2]]; *(&amp;v8 + v2) = v3; if ( (unsigned char)v3 &gt; 0xCCu &amp;&amp; v3 != -49 ) v1 = 1; ++v2; } while ( v2 != 15 ); cnt = 0; while ( 1 ) { ++cnt; *(&amp;v8 + cnt) =(unsigned char)(*(&amp;v8 + cnt - 1) + (*(int*)((int*)unk_8048980+cnt-1))); printf(&quot;%c&quot;,book[*(&amp;v8 + cnt)]); if ( cnt == 14 ) { return 0; } } *(&amp;v8 +cnt) = *(&amp;v8 +cnt); } int main() { char x[16]=&quot;ooooooooooooooo&quot;; unsigned char i; printf(&quot;flag{&quot;); sub_8048801(x); printf(&quot;}&quot;); return 0; } 转自实验吧，原文作者实验吧ID czr27]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wzezDingDing]]></title>
    <url>%2F2018%2F11%2F09%2FwzezDingDing%2F</url>
    <content type="text"><![CDATA[这个题目是一个64位的驱动，在ida里分析了一下。首先找到正常的驱动分发函数里，看看这个驱动都完成什么功能。下面是驱动分发函数中，比较iocontrol code的地方。然后进入每个处理分支，观察一下都做了什么。发现每个分支都有一个特点，满足相应的条件判断，就会将全局变量dword_148E0某位置为F。 比如： 88102004这个分支，当从ring3输入字符串为”^lejAJ]O” “MNIII” 时，会分别置dword_148E0第六位 第五位为F，两次在ring3调用DeviceIoControlcode即可。后面的分支每次按条件要求，依次在ring3调用DeviceIoControlcode， 让驱动走完每个iocontrol code的处理分支。注意：8810200c的分支是判断ring3的映像文件名是否含有HCTF这几个字符。流程还需要走一个其它分支，这里就选择了0x88102014，就是jmp loc12788，这个分支会给第一位置F接着写个ring3的程序，跑一下看看什么情况 HANDLE hDev = CreateFile(&quot;\\\\.\\Hctf&quot;,GENERIC_READ |GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,OPEN_EXISTING ,0, NULL); DWORD code=0; DWORD dwShellcodeSize=0x104; char InBuf[] = &quot;^lejAJ]O&quot;; char mniii[]=&quot;MNIII&quot;; char ret[]=&quot;\xc3\xc3\xc3\xc3\xc3\xc3\xc3\xc3\xc3\xc3\xc3\xc3\xc3\xc3\xc3\xc3&quot;; char OutBuf[0x100]={0}; DWORD dwRetBytes = 0; char OutBuf2[0x100]={0}; DeviceIoControl(hDev, 0x88102004,InBuf, 0x9, OutBuf, 0x100, &amp;dwRetBytes, 0); DeviceIoControl(hDev, 0x88102004,mniii, 0x6, OutBuf, 0x100, &amp;dwRetBytes, 0); DeviceIoControl(hDev, 0x88102008,ret, 16, OutBuf, 0x100, &amp;dwRetBytes, 0); DeviceIoControl(hDev, 0x8810200c,ret, 16, OutBuf, 0x100, &amp;dwRetBytes, 0); DeviceIoControl(hDev, 0x8810200c,ret, 16, OutBuf, 0x100, &amp;dwRetBytes, 0); DeviceIoControl(hDev, 0x88102014,ret, 16, OutBuf, 0x100, &amp;dwRetBytes, 0); DeviceIoControl(hDev, 0x88102010,ret, 16, OutBuf2, 0x100, &amp;dwRetBytes, 0); CloseHandle(hDev); 发现驱动直接crash在下面这个call里，调用到栈上的一个地址到这就太想吐槽了，crash在这后，发现里面有一部分代码，还有类似循环的代码，还以为要怎么补成一个计算flag的算法，尼玛最后知道就是补成栈平衡就行，真是没做过ctf啊，太天真了。。从ring3传进来的，然后在驱动里补齐。如下图所示这段代码需要填补上\x50\x41\x50\x48\x83\xec\x28\x59\xc3使堆栈平衡加上hctf{}格式就是flag了 转自CSDN博客，原链接]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这个FLAG有点怪]]></title>
    <url>%2F2018%2F11%2F09%2F%E8%BF%99%E4%B8%AAFLAG%E6%9C%89%E7%82%B9%E6%80%AA%2F</url>
    <content type="text"><![CDATA[APK文件丢apktool里，拆包，转jar，看源码注意这个func函数，我们要跟进去，但是func是加载so得到的IDA打开so文件，去找func，但是！！！没有！！！好的，我忍！dex加载so的时候，首先会导出函数中查找JNI_Onload函数，默认情况下，不需要我们管，但是可以重写JNI_Onload进行注册函数我们去找JNI_Onload函数点进去发现func字样，下面的函数是_cxa_begin_match点击跟进F5从上到下看，出现第一个奇怪的函数gun_arm_fini_29点击跟进去，知道功能为读取字符串用的返回继续分析源码中间有很多东西，是关于调用线程和检测程序的，总的来说就是一种简单的对抗gdb调试的思路吧！（猜的）然后继续看，我们刚刚输入的字符串进行了一个抑或加密，加密是以如下方式text[i]=text[i]^(i+1)进行的然后我们继续看如下语句这几个变量m_y，tempSt，tempabc貌似都没有定义啊！去init段找找吧查看init段，发现函数_cxa_chk_fail跟进去看关键代码在这，跟进sub_1A74函数这些变量类似于全局变量在这里被注册，在这里对m_y和tempabc进行了初始定义m_y的值为6tempabc的值为syctempabc赋值进过了一次gun_Unwind1函数，跟进去代码很简单，就是逐位转ascii后-2，在转回字符返回，偷个懒不截图了 然后回到_cxa_begin_match继续跟踪逻辑，这里调用了一个imp_Unwind_k函数进去查看可以看到是把穿进去的字符串右移6位，赋值给tempStr至此，刚刚上面3个未定义的变量值就都确定了回_cxa_begin_match函数，看下一句gun_armfini_33函数关键代码大概作用就是，把tempabc中的大写字母转小写，tempStr字符串则是移位2位，赋值给v15……【逻辑看的头疼】然后下面返回imp_Unwind_j函数，继续跟进去看分析,第一个if段，确定tempStr角标0 1 2 3 9 10的值，分析过程角标1和2的值相同，为111，转字符为o其他的根据判断条件，设角标9为x，可得方程(2*(x-1)-29)+(2*(x-1))+x+(x+31)-304==0，解方程x=51，python有个库为sympy，快速解方程 from sympy import * x=Symbol(&#39;x&#39;) print(solve((2*(x-1)-29)+(2*(x-1))+x+(x+31)-304, x)) 至此tempStr的值如下 tempStr[0] = &#39;G&#39; tempStr[1] = &#39;o&#39; tempStr[2] = &#39;o&#39; tempStr[3] = &#39;d&#39; tempStr[4] = &#39;&#39; tempStr[5] = &#39;&#39; tempStr[6] = &#39;&#39; tempStr[7] = &#39;&#39; tempStr[8] = &#39;&#39; tempStr[9] = &#39;3&#39; tempStr[10] = &#39;R&#39; 继续看第二个if条件，循环5次，分别计算出角标4~8的值，角标值异或0x11在加循环次数【次数从0开始算】要等于V6，V6的值根据&amp;szCmp得到，每次循环该地址加4szCmp的值双击跟进去直接看到分别为 R d r u ^最终得到tempStr的值为GoodCracK3R 回到_cxa_begin_match函数继续分析看接下来的if段，注意这里的desc和src去看变量定义字符串s其实就是我们要找的，目前已经能确定出前11位GoodCracK3R，src是角标8的首地址，v21和s相差11，作为结束位置11位之后的值将赋值给dest并且这里我们给seed赋值，他的位置正好是加密后串（s串的第9、10、11位，也就是K3R）这个seed后面有用！之后进入gun_armfini_21函数，首先是进入gun_armfini_23函数，这里利用了seed值对v8生成了一个256长度的int数组！用python还原一下逻辑 def make(str,lens): a=[] for i in range(256): a.append(i) pos=0 pos_temp=0 for i in range(256): temp = a[i] pos_temp=(ord(str[pos])+a[i]+pos_temp)&amp;0xff a[i]=a[pos_temp] a[pos_temp]=temp pos=((pos+1)%lens)&amp;0xff return a 然后我们这个v8数组后面还会用到。之后进入gun_armfini_36函数，这个函数主要就是对11位之后的字符串进行了处理 然后我们还是回到_cxa_begin_match函数！接近结束了！我们看到是用sprintf函数对v18进行赋值（用11位以后，加密过的字符）然后进入gun_arm_ldiv0函数去匹配！调用了gun_Unwind函数继续跟进去功能就是把字符串转ascii逐位-2最后我们看看它在做什么？11位之后的内容，进过加密，以16进制形式输出 0xa8 0xe5 0x58 0x8f 0x7e 0x03 0xf7 0x58 然后根据上面的分析，我们就可以得到gun_armfini_33加密以后后八位的字符串是啥了！ def test(): a=make(&#39;K3R&#39;,3) value=[0xa8,0xe5,0x58,0x8f,0x7e,0x03,0xf7,0x58] temp1=0 temp2=0 temp3=0 flag=&#39;&#39; print a for i in value: temp1=(temp1+1)&amp;0xff temp2=a[temp1] temp3=(temp3+temp2)&amp;0xff a[temp1]=a[temp3] a[temp3]=temp2 flag+=chr(i^a[(a[temp1]+temp2)&amp;0xff]) print flag 得到GoodCracK3R;{0jN|B6接下来只需要逆向一下gun_armfini_33函数，再移位回去再抑或一下就得到答案了！解密程序如下 ppp=&quot;GoodCracK3R;{0jN|B6&quot; key = &#39;syc&#39; flag=[] for i in ppp: flag.append(ord(i)) print flag for j in range(len(flag)): if flag[j]&gt;=ord(&#39;a&#39;) and flag[j]&lt;=ord(&#39;z&#39;): flag[j]=(flag[j]-97+26-ord(key[j%3])+97)%26+97 elif flag[j]&gt;=ord(&#39;A&#39;) and flag[j]&lt;=ord(&#39;Z&#39;): flag[j]=(flag[j]-65+26-ord(key[j%3])+97)%26+65 newflag=&#39;&#39; for i in range(6,6+len(flag)): newflag+=chr(flag[i%len(flag)]^(i-5)) print newflag 得到FLAG xctf{hgJ7Q=|8a\wV;A~}}Wc}]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有一个程序加密得如下]]></title>
    <url>%2F2018%2F11%2F09%2F%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%8A%A0%E5%AF%86%E5%BE%97%E5%A6%82%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[题目只给了一串类似乱码的字符串0be6770IigHXZpz9hQYR1fpl15R0z9MUalmYEPhJeEN/sRklL6wQw5yQ7SAyT6tKGJNY0AxnyzS/L7zWQII=程序是.pyc利用工具将pyc转成py工具名EasyPythonDecompiler得到如下代码 # Embedded file name: ./rev200.py import sys from hashlib import md5 import base64 from time import time from datetime import datetime UC_KEY = &#39;123456789&#39; def authcode(string, operation = &#39;DECODE&#39;, key = UC_KEY, expiry = 0): ckey_length = 4 if key == &#39;&#39;: key = md5(UC_KEY.encode(&#39;utf-8&#39;)).hexdigest() else: key = md5(key.encode(&#39;utf-8&#39;)).hexdigest() keya = md5(key[0:16].encode(&#39;utf-8&#39;)).hexdigest() keyb = md5(key[16:32].encode(&#39;utf-8&#39;)).hexdigest() if ckey_length == 0: keyc = &#39;&#39; elif operation == &#39;DECODE&#39;: keyc = string[0:ckey_length] elif operation == &#39;ENCODE&#39;: keyc = md5(str(datetime.now().microsecond).encode(&#39;utf-8&#39;)).hexdigest()[-ckey_length:] else: return cryptkey = keya + md5((keya + keyc).encode(&#39;utf-8&#39;)).hexdigest() key_length = len(cryptkey) if operation == &#39;DECODE&#39;: string = base64.b64decode(string[ckey_length:]) elif operation == &#39;ENCODE&#39;: if expiry == 0: string = &#39;0000000000&#39; + md5((string + keyb).encode(&#39;utf-8&#39;)).hexdigest()[0:16] + string else: string = &#39;%10d&#39; % (expiry + int(time())) + md5((string + keyb).encode(&#39;utf-8&#39;)).hexdigest()[0:16] + string else: return string_length = len(string) result = &#39;&#39; box = range(256) rndkey = [0] * 256 for i in range(256): rndkey[i] = ord(cryptkey[i % key_length]) j = 0 for i in range(256): j = (j + box[i] + rndkey[i]) % 256 tmp = box[i] box[i] = box[j] box[j] = tmp a = j = 0 for i in range(string_length): a = (a + 1) % 256 j = (j + box[a]) % 256 tmp = box[a] box[a] = box[j] box[j] = tmp result += chr(ord(string[i]) ^ box[(box[a] + box[j]) % 256]) if operation == &#39;DECODE&#39;: if not result[0:10].isdigit() or int(result[0:10]) == 0 or int(result[0:10]) - int(time()) &gt; 0: if result[10:26] == md5(result[26:].encode(&#39;utf-8&#39;) + keyb).hexdigest()[0:16]: return result[26:] else: return &#39;&#39; else: return &#39;&#39; else: return keyc + base64.b64encode(result) if __name__ == &#39;__main__&#39;: if len(sys.argv) &lt; 3: exit(1) ex = 20 for i in range(1, len(sys.argv), 2): a = sys.argv[i] b = sys.argv[i + 1] if a == &#39;-t&#39;: ex = int(b) elif a == &#39;-e&#39;: encoded = authcode(b, &#39;ENCODE&#39;, expiry=ex) print encoded elif a == &#39;-d&#39;: decoded = authcode(b, &#39;DECODE&#39;, expiry=ex) print decoded 分析源码，执行的时候加入-d参数，值为题目给的乱码，但是返回的却是空注意该段 if operation == &#39;DECODE&#39;: if not result[0:10].isdigit() or int(result[0:10]) == 0 or int(result[0:10]) - int(time()) &gt; 0: if result[10:26] == md5(result[26:].encode(&#39;utf-8&#39;) + keyb).hexdigest()[0:16]: return result[26:] else: return &#39;&#39; else: return &#39;&#39; else: return keyc + base64.b64encode(result) 我们直接修改源码，跳过判断，在if之前直接print string，执行可得到 1429861566556d9f4f29671810DUTCTF{2u0_chu_14i_d3_5hi_h3n74i} 得到flag值DUTCTF{2u0_chu_14i_d3_5hi_h3n74i}]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[证明自己吧]]></title>
    <url>%2F2018%2F11%2F09%2F%E8%AF%81%E6%98%8E%E8%87%AA%E5%B7%B1%E5%90%A7%2F</url>
    <content type="text"><![CDATA[OD法标准的C语言逆向分析程序，只要一路跟进CALL就能找到密码算法的位置并分析流程就可以了。找到算法CALL跟进后就会注意到一个指令：REPNE SCAS BYTE PTR ES:[EDI]这也是本例子唯一困惑我的地方，查了一下这条指令的用法，发现他其实是结合not ecx和sub edi，ecx计算输入字符串长度的，要求是长度为14位 当输入长度为14位密码时，进入密码运算步骤，如下图关键循环处，在这里只对输入的密码简单的采用了xor 20的运算，得到一组新的序列，存回原地址 读取一段栈区的14字节数据，并每个进行ADD BF运算，结果取出一个字节组成一个新的14字节数据(这段14byte数据没注意怎么来的，有兴趣的可以自己跟一下) 用处理过的输入密码和上面处理过的14字节数据进行逐个比较，全部正确则验证通过。也就是说，输入的密码(ascii码)XOR 20h要等于以下的14个字节数据。 63 52 14 43 4B 69 53 73 4F 65 14 53 59 01 所以对这14个字节X0R 20h就能还原出原始密码！ 转自实验吧，原文作者实验吧ID kyogre6105 IDA法ida直接看出验证算法在if里的sub函数里打开看啊看。。看到v5到v7定义了一堆诡异的数据因该是加密的数据再看看算法先输入a1，求长度，异或0x20在比较所以只要吧那堆数据减五异或20就可以了 转自实验吧，原文作者实验吧ID Zarcs]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[此处无声]]></title>
    <url>%2F2018%2F11%2F09%2F%E6%AD%A4%E5%A4%84%E6%97%A0%E5%A3%B0%2F</url>
    <content type="text"><![CDATA[要求给出nsfocus的注册码。因为涉及到MD5与RC6加密算法，所以比较烦人。无壳，但有所保护，可以无视。运行起来，bp MessageBoxA下断点回溯可以一点一点找到关键代码。首先判断 00401882 |. 83F9 20 cmp ecx, 20 ; 判断长度32位 00401885 |. 75 28 jnz short CrackMe2.004018AF 00401887 |. 33C9 xor ecx, ecx 00401889 |&gt; 8A0411 /mov al, byte ptr ds:[ecx+edx] 0040188C |. 3C 30 |cmp al, 30 ; 与0比较 0040188E |. 7C 04 |jl short CrackMe2.00401894 00401890 |. 3C 39 |cmp al, 39 ; 与9比较 00401892 |. 7E 08 |jle short CrackMe2.0040189C 00401894 |&gt; 3C 41 |cmp al, 41 00401896 |. 7C 0A |jl short CrackMe2.004018A2 ; 与A比较 00401898 |. 3C 46 |cmp al, 46 0040189A |. 7F 06 |jg short CrackMe2.004018A2 ; 与F比较 0040189C |&gt; 41 |inc ecx 0040189D |. 83F9 20 |cmp ecx, 20 004018A0 |.^ 7C E7 \jl short CrackMe2.00401889 004018A2 |&gt; 83F9 20 cmp ecx, 20 ; 这里正常 004018A5 |. 75 08 jnz short CrackMe2.004018AF 004018A7 |. B8 01000000 mov eax, 1 这里确定注册码为32位，且字符只可能为0-F。瞬间不淡定了，32位，很可能就出现MD5。而注册字符只可能是0-F。接着分析,到最后比较之处.在数据窗口发现如下部分。 0012F664 35 47 82 5C 33 8C 85 77 9A 67 45 7A 6D 5C 16 47 5G俓3寘w歡Ezm\G 0012F674 F6 AD DD 6C 46 EB B6 44 BD A2 65 36 6E 8C A6 75 霏輑F攵D舰e6n對u 0012F684 B9 B7 DD 1C 42 1E 00 5B C9 A7 F7 0B 84 8E 3D 0E 狗?B.[骚?剮= 其中B9B7DD1C421E005BC9A7F70B848E3D0E是nsfocus的MD5值。F6ADDD6C46EBB644BDA265366E8CA675是个人输入的注册码[这里为展示输入为正确注册码]。而上面一串3547825C338C85779A67457A6D5C1647瞬间让我不淡定了。也就是说，CrackMe判断方式为Eecode(Key)=MD5(Name)。加密算法只用到0-F，且可能有自身的密钥串3547825C338C85779A67457A6D5C1647。猜想可能用到RC6加密算法。因为有一种方式为RC6Decrypt(MD5(Name))=Key。也算是偶尔查到看雪的一个帖子。这样用RC6解密试一下密钥串果然是3547825C338C85779A67457A6D5C1647好吧，周折之下总算得到Key:nsfocus:F6ADDD6C46EBB644BDA265366E8CA675 转自实验吧，原文作者实验吧ID bigtree]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[该题不简单-----IDA算法分析]]></title>
    <url>%2F2018%2F11%2F09%2F%E8%AF%A5%E9%A2%98%E4%B8%8D%E7%AE%80%E5%8D%95-----IDA%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[其实此题并非很难的嘛，宝宝这就讲一下啦~首先用IDA载入，审阅左侧函数名列表，看到第一个函数就是DialogFunc，顾名思义为“对话函数”，极有可能负责了交互界面的相关功能，我们双击它，看到右侧汇编区域中出现“密钥无效”（“密钥无效”存储在变量aZgb里）等敏感字符串，这正是出现在交互窗口中的信息，我们自然而然想到去分析返回“密钥无效”这一信息的逻辑判断的相关算法，我们F5看看DialogFunc的源码：发现这里有一个if判断（这里当然指的是内层那个啦),在!sub_4011D0()的值为false 即0时，就会弹出消息框，内容是aZgb即密钥无效，也就是说，当输入正确的注册码（即flag）时,!sub_4011D0()值就会是1，即sub_4011D0()的返回值为0，我们要做的就是分析一下怎么才能让sub_4011D0()返回0。查看sub_4011D0()的源码：其中，有两个GetDlgItemTextA，第一个是读取用户名，第二个是读取注册码；我们现在来看返回值，是result，我们期望result的值是0，那么执行外层if时，条件应成立，实际上用户名是hello时已经能保证成立了，这个很明显，所以关键就是分析内层的逻辑，内层的那个if其实又是句没用的废话…这里真正关键的问题在于，让result的值是0，即： lstrcmpA(&amp;String1, String) != 0的值是0，即lstrcmpA(&amp;String1, String)的值是0，即string1等于string，此处lstrcmp函数的功能大家自己查百度不难了解到，不懂的朋友自己去看一下很容易就看懂了。那么string1就是输入的注册码也就是我们的flag，也就是说正确的flag就是string，我们只要分析出string这一字符串到底是什么就OK了。注意，开始的时候string就是用户名hello，但是就在最后关头，一个字符串尾接函数lstrcatA已经将string改变了，所做的改变就是在原来的“hello”后面接上了字符串string2，于是，现在的任务又变成了确定string2的值，那么string2的值是怎么确定的呢？正是上面那段while循环的算法，我们下面给出这段的截图：算法对string的每个字符进行计算，结果赋给string2的对应字符，就把string2算出来了，我写出了对应的C语言代码： #include &lt;stdio.h&gt; int main(){ int a[5]; int r[5]; int i; for(i=0;i&lt;=4;i++){ a[i]=getchar(); r[i]=0; } for(i=0;i&lt;=4;i++){ r[i]=(i+ i*a[i]*a[i]) % 66 + 33; } printf(&quot;\n&quot;); for(i=0;i&lt;=4;i++){ printf(&quot;%c&quot;,r[i]); } } 运行程序输入“hello”，就会打印正确的string2：所以string的值就是“hello!GAOU”，即flag~~~ 转自实验吧，原文作者实验吧ID Diyah Velly-Magpie]]></content>
      <categories>
        <category>实验吧Writeup</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
        <tag>逆向WP</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
</search>
